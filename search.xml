<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test.md</title>
    <url>/2020/08/03/test/</url>
    <content><![CDATA[<h1 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h1><p>heheheh <a id="more"></a> hahaha</p>
<h2 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>世间所有的相遇，都是久别重逢</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<div class="note default">
            <p>default 提示块标签</p>
          </div>

<div class="note primary">
            <p>primary 提示块标签</p>
          </div>

<div class="note success">
            <p>success 提示块标签</p>
          </div>

<div class="note info">
            <p>info 提示块标签</p>
          </div>

<div class="note warning">
            <p>warning 提示块标签</p>
          </div>

<div class="note danger">
            <p>danger 提示块标签</p>
          </div>

<span class="label default">默认</span> <span class="label primary">主要</span> <span class="label success">成功</span> <span class="label info">信息</span> <span class="label warning">警告</span> <span class="label danger">危险</span> 
<span class="label success">这是成功的信息</span>

<div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">tab 1</a></li><li class="tab"><a href="#tab-2">tab 2</a></li><li class="tab"><a href="#tab-3">A</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><strong>选项卡 1</strong> </p></div><div class="tab-pane" id="tab-2"><p><strong>选项卡 2</strong></p></div><div class="tab-pane" id="tab-3"><p><strong>选项卡 3</strong> 名字为A</p></div></div></div>

<a class="btn" href="url" title="[title]">
            <i class="fa fa-icon [class]"></i>text
          </a>

<div><a class="btn" href="https://tding.top/ " title="这是小丁的个人博客首页">
            <i class="fa fa-home fa-fw"></i>首页
          </a></div>

<div class="text-center"><div><a class="btn" href="https://tding.top/ " title="这是小丁的个人博客首页">
            <i class="fa fa-home fa-fw"></i>首页
          </a> <a class="btn" href="https://tding.top/movies/ " title="豆瓣电影">
            <i class="fa fa-film fa-fw"></i>观影
          </a> <a class="btn" href="https://tding.top/books/ " title="豆瓣读书">
            <i class="fa fa-book fa-fw"></i>阅读
          </a></div></div>]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test1</tag>
        <tag>test2</tag>
      </tags>
  </entry>
  <entry>
    <title>160个CM-001-Acidburn</title>
    <url>/2017/04/11/160%E4%B8%AACM-001-Acidburn/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>刚刚知道了有适合新手练手的160个CM，就发誓要破解全部的160个CrackMe，就算是小小白，也要努力刚起来！</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：Acid burn.exe</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>PEid，OD</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>1.运行界面<br>首先是一个nag窗口提示，点击确定之后是选择check序列号名字或check序列号或退出，之后会显示所选择的界面进行验证然后弹出提示信息。<br>所以这个CM的任务有三个：<br>1）去除nag<br>2）解决Serial<br>3）解决Name/Serial</p>
<hr>
<p>2.查壳<br>这是一个Delphi程序，没有加壳</p>
<hr>
<p>3.去除nag<br>根据一般的思路，搜索字符串，跟进函数之后，将MassegeBox函数nop掉就可以完美爆破nag窗口，不过这个程序不行，如果直接nop掉会发现提示错误的窗口也不会出现了<br>后来发现在MassegeBox函数的外层的外层函数有一个跳转，将je改成无条件跳转jmp就能直接跳过弹出欢迎信息的界面。<br><img src="https://ooo.0o0.ooo/2017/04/11/58ecba79e8f39.png" alt="0"></p>
<hr>
<p>4.解决Serial<br>搜索字符串，在0042F4F1这个函数中会对比eax和edx中的内容，然后一个关键的跳转决定弹出成功或是失败的弹框，此时可以修改jnz这个跳转去爆破。<br><img src="https://ooo.0o0.ooo/2017/04/11/58ecbe9c13be0.png" alt="1"><br>不过跟进函数中，可以很容易的得到正确的key是Hello Dude！<br><img src="https://ooo.0o0.ooo/2017/04/11/58ecbe093ba3d.png" alt="2"><br><img src="https://ooo.0o0.ooo/2017/04/11/58ecc1145f4b9.png" alt="3"></p>
<hr>
<p>5.爆破Name/Serial<br>同样搜索字符串，在关键跳转上方有个call，猜想可能是验证序列号的函数，先跟进去看看<br><img src="https://ooo.0o0.ooo/2017/04/11/58ecc38cdd334.png" alt="4"><br>跟进去能发现，这个函数正是上面的0042F4F1函数，其实在eax寄存器中已经可以看到1111对应的序列号是什么了，其实在右下角的堆栈区也能看到排列清晰的我们输入的Name/Serial和真正的Name/Serial，直接输入就行，或者直接将跳转指令nop掉也能破解。<br><img src="https://ooo.0o0.ooo/2017/04/11/58ecdc02e1118.png" alt="5"><br><img src="https://ooo.0o0.ooo/2017/04/11/58ecc38cdd334.png" alt="6"></p>
<hr>
<p>6.Name/Serial的算法<br>也可以分析一下得出Name/Serial关系，将0x0042FA87 - 0x0042FB03之间的代码单独拎出来，首先会有一个判断，判断输入的Name长度是否超过4，这个限定条件可以手动改成与0比较就行啦，后面的分析见图中的注释。<br><img src="https://ooo.0o0.ooo/2017/04/11/58ece18127399.png" alt="7"></p>
<hr>
<p>小结：<br>我也看得出来这个CM已经很简单很明了了，但是我真得弄了一天。在感叹自己太弱了的同时，其实也是很有成就感的，我想我还需要很多时间去学习去沉淀，加油。</p>
]]></content>
      <tags>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title>160个CM-002-Akfayas1</title>
    <url>/2017/04/14/160%E4%B8%AACM-002-Afkayas1/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>第二个咯~</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：Akfaya.1.exe</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>PEid，OD</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>1.运行界面<br>运行起来就是直接填写Name/Serial进行验证，所以需要做的很明确了</p>
<hr>
<p>2.查壳<br>用PEid发现没有壳</p>
<hr>
<p>3.爆破Name/Serial<br>搜索Unicode，下断点，可以看到关键跳转，直接nop掉就可以爆破成功了。<br><img src="https://ooo.0o0.ooo/2017/04/12/58edc689a7919.png" alt="0"><br><img src="https://ooo.0o0.ooo/2017/04/12/58edc721979fb.png" alt="1"></p>
<hr>
<p>4.算法分析<br>在关键的跳转向上面找，发现了几个关于字符串处理的函数，所以不断的下断点尝试，可以找到主要的算法在0040240F-0040258B之间，最主要的两端在下图中，其他的部分大多是释放内存这些。<br><img src="https://ooo.0o0.ooo/2017/04/12/58eddb4de1c11.png" alt="2"><br>先用Name的字符串长度乘以17CFB之后加上Name第一个字符的ascii码值<br><img src="https://ooo.0o0.ooo/2017/04/12/58eddb51117a0.png" alt="3"><br>最后在前面加上字符串“AKA-”，连接在一起构成Name对应的Serial<br>用C语言写出这个算法的话如下图：<br><img src="https://ooo.0o0.ooo/2017/04/12/58edde7bc3fac.png" alt="4"><br><img src="https://ooo.0o0.ooo/2017/04/12/58edde897b5d6.png" alt="5"></p>
<hr>
<p>哦耶！</p>
]]></content>
      <tags>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title>160个CM-003-Akfayas2</title>
    <url>/2017/04/17/160%E4%B8%AACM-003-Afkayas2/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>第三个咯~</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：Akfaya.2.exe</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>PEid，OD</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>1.运行界面<br>运行起来先显示一个有名字的小画面，挺有意思的，然后直接填写Name/Serial进行验证</p>
<hr>
<p>2.查壳<br>用PEid发现没有壳</p>
<hr>
<p>3.爆破Name/Serial<br>爆破的方法和Akfaya.1.exe的一样</p>
<hr>
<p>4.算法分析<br>首先的一部分与Akfaya.1.exe的相似<br><img src="https://ooo.0o0.ooo/2017/04/13/58ef2a1f12d71.png" alt="0"><br>取Name的字符串长度，乘以15B38h，再加上Name第一个字符的ascii码值，最后将十六进制转换成十进制<br>但是比Akfaya.1.exe多出的算法部分主要是浮点数，我找到了四处<br>1）<br><img src="https://ooo.0o0.ooo/2017/04/13/58ef2ad7e7c5c.png" alt="1"><br>主要实现的过程是将Serial加上2<br>2）<br><img src="https://ooo.0o0.ooo/2017/04/13/58ef2b2228517.png" alt="2"><br>主要实现将Serial乘以3再减去2<br>3）<br><img src="https://ooo.0o0.ooo/2017/04/13/58ef2b6004ecb.png" alt="3"><br>主要实现将Serial减去-15，也就是加上15<br>4）<br><img src="https://ooo.0o0.ooo/2017/04/13/58ef2ba7c17eb.png" alt="4"><br>第四个没有做什么操作，不过最后将栈中真正的Serial给清零了<br>如果用C语言实现这个算法的话如图：<br><img src="https://ooo.0o0.ooo/2017/04/13/58ef81aca0f39.png" alt="5"><br><img src="https://ooo.0o0.ooo/2017/04/13/58ef81cae50cb.png" alt="6"></p>
<hr>
<p>哦耶！</p>
]]></content>
      <tags>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title>160个CM-004-ajj1</title>
    <url>/2017/04/22/160%E4%B8%AACM-004-ajj1/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>第4个咯~</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：ajj1.exe</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>PEid，OD，DeDeDark</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>1.运行界面<br>运行起来要求填写用户名和注册码，下面是一块阴影矩形，如果鼠标停留在界面内，会出现一行提示“如果注册成功，程序会出现朱茵小姐的一副靓照”，没有确定按钮</p>
<hr>
<p>2.查壳<br>用PEid查壳，发现没有加壳，是Dephi程序</p>
<hr>
<p>3.查看事件<br>无法查找字符串了，又没有确定按钮，于是我使用DeDeDark查看了相关的事件，并且在相应的入口下了断点<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1af2a10b6c.png" alt="0"></p>
<hr>
<p>4.载入OD分析<br>1)每输入一个用户名的字符，就会断在KerUp的入口<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1afa063c37.png" alt="1"><br>1)每输入一个注册码的字符，就会断在chkcode的入口<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b0606138c.png" alt="2"><br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b06dc11da.png" alt="3"><br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b079da99f.png" alt="4"><br>可以看到Serial的生成规则是“黑头Sun Bird(Name长度+5)dseloffc-012-OK（Name）”<br>但是就算注册码正确了，也不会有注册成功的效果出现，因为在判断之后会根据对错给相应的内存单元赋值<br>可是为什么不会直接出现注册成功的效果呢，猜测可能是要点击触发下一个事件<br>3）单击阴影矩形，会断在Panel1Click<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b5ef685fd.png" alt="5"><br>可是从上面的分析，我们可以知道，如果注册码正确的话，[ebx+0x30C]被赋值3E，否则为0，所以不管正不正确这里都会跳转<br>4）试着双击，依次断在Panel1Click，Panel1DblClikc<br>在Panel1DblClikck中会对[ebx+0x30C]再次赋值0x85<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b768ef825.png" alt="6"><br>之后再单击到Panel1Click进行判断<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1cc5285233.png" alt="7"><br>这次会将会提示注册成功，随后会显示朱茵小姐的照片。</p>
<hr>
<p>哦耶！</p>
]]></content>
      <tags>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title>160个CM-006-aLoNg3x1</title>
    <url>/2017/05/06/160%E4%B8%AACM-006-aLoNg3x1/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>前段时间面试篮球赛各种事情忙飞了，补觉完毕后继续Crack</p>
<a id="more"></a>

<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：aLoNg3x.1.exe</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>PEid，OD，DeDeDark</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>1.运行界面<br>需要填写Nome和Codice，ok按钮是灰色不可点击状态，还有一个Cancella按钮提示说如果按钮无效就破解不了<br>最初以为Cancella按钮是退出按钮，后来发现是将注册码清零的按钮</p>
<hr>
<p>2.查壳<br>用PEid查壳，发现没有加壳，是Dephi程序</p>
<hr>
<p>3.查看事件<br>于是我使用DeDeDark查看了相关的事件，并且在相应的入口下了断点<br><img src="https://ooo.0o0.ooo/2017/05/06/590d5284de72b.png" alt="0"></p>
<hr>
<p>4.载入OD分析<br>1)每输入一个Nome的字符，就会断在NomeChange的入口<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1afa063c37.png" alt="1"></p>
<p>2)每输入一个注册码的字符，就会断在chkcode的入口<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b0606138c.png" alt="2"><br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b06dc11da.png" alt="3"><br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b079da99f.png" alt="4"><br>可以看到Serial的生成规则是“黑头Sun Bird(Name长度+5)dseloffc-012-OK（Name）”<br>但是就算注册码正确了，也不会有注册成功的效果出现，因为在判断之后会根据对错给相应的内存单元赋值<br>可是为什么不会直接出现注册成功的效果呢，猜测可能是要点击触发下一个事件</p>
<p>3）单击阴影矩形，会断在Panel1Click<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b5ef685fd.png" alt="5"><br>可是从上面的分析，我们可以知道，如果注册码正确的话，[ebx+0x30C]被赋值3E，否则为0，所以不管正不正确这里都会跳转</p>
<p>4）试着双击，依次断在Panel1Click，Panel1DblClikc<br>在Panel1DblClikck中会对[ebx+0x30C]再次赋值0x85<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1b768ef825.png" alt="6"><br>之后再单击到Panel1Click进行判断<br><img src="https://ooo.0o0.ooo/2017/04/15/58f1cc5285233.png" alt="7"><br>这次会将会提示注册成功，随后会显示朱茵小姐的照片。</p>
<hr>
<p>哦耶！</p>
]]></content>
      <tags>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP套接字编程</title>
    <url>/2016/11/09/UDP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>由于UDP是无连接的通信方式，所以不需要并发技术就能能实现与多用户客户端的通信，只需要通过套接字的地址加以区分。<br>下面是我用C语言实现一个基于TCP协议的单用户客户端跟服务器的连接和数据交互及处理的过程的小程序。</p>
<a id="more"></a>
<p><img src="https://ooo.0o0.ooo/2016/11/09/5822a8f8975e1.png" alt="测试结果"></p>
<p>客户端通过读入服务器端的IP连接到服务器，连接成功后服务器端显示客户端的IP，端口号和客户端发送过来的信息；<br>客户端能循环从命令行读入数据，服务器循环接受客户端的数据并显示，并返回到客户端，客户端显示服务器的IP和返回的数据；<br>当客户端输入”quit”时，服务器端和客户端都关闭连接并退出<br>具体实现的代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Server.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 1234</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>, <span class="title">client</span>;</span></span><br><span class="line">  <span class="keyword">int</span> sin_size, num;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;Create socket failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">        </span><br><span class="line">  bzero(&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line">  server.sin_family = AF_INET;</span><br><span class="line">  server.sin_port = htons(PORT);</span><br><span class="line">  server.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  <span class="keyword">int</span> opt =<span class="number">1</span>;</span><br><span class="line">  setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt)); <span class="comment">//地址复用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bind(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Bind error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;<span class="comment">//bind</span></span><br><span class="line">  sin_size = <span class="keyword">sizeof</span>(struct sockaddr_in); </span><br><span class="line">        </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;     </span><br><span class="line">    num = recvfrom(sockfd, buf, <span class="number">100</span>, <span class="number">0</span>, (struct sockaddr *)&amp;client, &amp;sin_size);</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)  &#123;</span><br><span class="line">      perror(<span class="string">&quot;recvfrom error.&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buf[num] =<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You got a message (%s) from a client(IP:%s)(port:%d)\n&quot;</span>, buf,inet_ntoa(client.sin_addr),htons(client.sin_port));</span><br><span class="line">    sendto(sockfd,buf,<span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;client, sin_size);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf,<span class="string">&quot;quit\0&quot;</span>)==<span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Client*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 1234</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd,numbytes;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>],sendbuf[<span class="number">100</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">he</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>,<span class="title">reply</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s  (IP address)  (Message)\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>((he = gethostbyname(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;gethostbyname error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;Create socket failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">        </span><br><span class="line">  bzero(&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line">  server.sin_family = AF_INET;</span><br><span class="line">  server.sin_port = htons(PORT);</span><br><span class="line">  server.sin_addr = *((struct in_addr *) he-&gt;h_addr);</span><br><span class="line">  sendto(fd, argv[<span class="number">2</span>], <span class="built_in">strlen</span>(argv[<span class="number">2</span>]), <span class="number">0</span>, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">  <span class="keyword">int</span> len=<span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    numbytes = recvfrom(fd,buf, <span class="number">100</span>, <span class="number">0</span>, (struct sockaddr *)&amp;reply, &amp;len);      </span><br><span class="line">    <span class="keyword">if</span> (numbytes ==<span class="number">-1</span>)&#123;</span><br><span class="line">      perror(<span class="string">&quot;recvfrom error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (len != <span class="keyword">sizeof</span>(struct sockaddr_in) || <span class="built_in">memcmp</span>((<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;server,(<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;reply, len)!= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;receive message from other server.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[numbytes] =<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you got a message from %s : %s\n&quot;</span>,inet_ntoa(server.sin_addr),buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your words:&quot;</span>);</span><br><span class="line">    gets(sendbuf);</span><br><span class="line">    sendto(fd, sendbuf, <span class="number">100</span>, <span class="number">0</span>, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(sendbuf,<span class="string">&quot;quit&quot;</span>)==<span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>不过UDP是面向无连接的，所以不可靠。所以会有遇到很多问题，很多细节需要在在代码中去完善。目前正在学习探索ing….</p>
]]></content>
      <tags>
        <tag>网络编程</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Upack文件头分析</title>
    <url>/2017/02/18/Upack%E6%96%87%E4%BB%B6%E5%A4%B4%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>因为最近都在学习PE文件相关的姿势，突然想起来《逆向工程核心原理》中有一个Upack文件，当时觉得特别有趣！现在再拿出来分析一下。</p>
<a id="more"></a>
<p>1）DOS头和NT头重叠<br>notepad.exe:<br>1.可以看到NT头从000000E0开始；<br>2.OS头还有插桩和其他的信息；<br><img src="https://ooo.0o0.ooo/2017/03/27/58d89d0095c89.png" alt="0"><br>notepad_upack.exe:<br>1.NT头的位置已经从000000E0变成了00000010；<br>2.DOS头中已经没有插桩和其他信息了，倒是包含了kernel32.dll字符串，推测DOS头和NT头不仅重叠了，其他的不太重要的字段可能也已经修改成了其他的信息，可能与引入函数这些有关，后面看能不能分析到。<br><img src="https://ooo.0o0.ooo/2017/03/27/58d89d049556b.png" alt="1"></p>
<p>2）可选头中的其他信息<br>notepad.exe:<br>1.可选头大小是E0，节表从1D8开始<br>2.入口偏移地址是0000739D<br>3.映像大小14000<br>4.PE头大小400<br>5.DataDirectory数组的个数是10<br>6.引入表的地址是00007604，大小是C8<br><img src="https://ooo.0o0.ooo/2017/03/27/58d8a016786c1.png" alt="2"><br>notepad_upack.exe:<br>1.可选头大小是148h，节表从170开始<br>2.入口偏移地址是00001018<br>3.映像大小28000<br>4.PE头大小200<br>5.DataDirectory数组的个数是A<br>6.引入表的地址是000271EE，大小是14<br><img src="https://ooo.0o0.ooo/2017/03/27/58d8a0834ce4d.png" alt="3"><br>1.可选头的尺寸增大后，在原可选头的后面空白区域就可以加入自己想要加入的信息了，因为Upack是一个加密压缩，所以猜测PE头被压缩重叠就是为了腾出空白的位置能插入解码代码。<br>2.DataDirectory数组的个数从10h改到A，但是有效的个数最多只有10个，所以可能从第10h到A的空间也用来覆盖解码代码了。</p>
<p>3）节区重叠<br><img src="https://ooo.0o0.ooo/2017/03/27/58d8a6c0214a1.png" alt="4"><br>1.看notepad_upack.exe的节区信息，看到很不寻常的地方。第一节区和第三节区在文件中的偏移地址和大小都是相同的，第一节区和第三节区重叠了。<br>2.而且00000010-000001F0属于PE头的部分，而PE头的大小加上节表一共200h，相比之下第二节区在文件中的大小显得很大，所以可能源文件就压缩在第二节区中。<br>3.第一节区在内存中的大小是14000，和notepad.exe的映像大小相等，所以由此可以猜测在第二节区中的压缩文件可能在加载到内存中的时候，整体解码到了第一节区中。</p>
<p>4）引入表<br>notepad_upack.exe的引入表的地址是000271EE，大小是14<br>000271EE在第三节区中，所以文件偏移=271EE-27000+0=1EE<br>所以引入表的文件偏移是1EE<br><img src="https://ooo.0o0.ooo/2017/03/27/58d8ac6ee4c6d.png" alt="5"><br>这个结构的后两个元素分别是Name和IAT，所以可以在00000002处看到名字kernel32.dll（之前的截图中可以看到），IAT的地址是000011E8，在第一节区，再次转换成文件偏移地址=000011E8-00001000+0=1E8<br><img src="https://ooo.0o0.ooo/2017/03/27/58d8ad903793e.png" alt="6"><br>在1E8处可以看到导入了两个API，偏移地址是28和BE<br><img src="https://ooo.0o0.ooo/2017/03/27/58d8adfde4786.png" alt="7"><br>引入的两个函数是LoadLobraryA和GetProcAddress，有了这两个函数其实就已经可以随意调用自己想要调用的任何函数了。</p>
]]></content>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>一个让你先空欢喜的RegisterMe1</title>
    <url>/2017/05/18/%E4%B8%80%E4%B8%AA%E8%AE%A9%E4%BD%A0%E5%85%88%E7%A9%BA%E6%AC%A2%E5%96%9C%E7%9A%84RegisterMe1/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>如果单纯爆破的话，这个CM不仔细看还真不容易发现自己没有爆破成功，情绪起伏呀</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：RegisterMe1.exe</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>PEid，OD</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>1.运行界面<br>很简单的界面，上面灰色的字提醒是否注册，下面要求输入Serial<br><img src="https://ooo.0o0.ooo/2017/05/22/5922e7b379f43.png" alt="0"></p>
<hr>
<p>2.查壳<br>显示没有加壳</p>
<hr>
<p>3.搜索字符串<br><img src="https://ooo.0o0.ooo/2017/05/22/5922e905e14ea.png" alt="1"><br>可以看到，提示错误或成功的信息都封装在函数中，所以搜索下哪里调用了<br><img src="https://ooo.0o0.ooo/2017/05/22/5922e908c9767.png" alt="2"><br>在一个函数后面，紧接着检测了eax是否为零，所以主要的比较过程在函数004010FC中</p>
<hr>
<p>4.函数004010FC<br><img src="https://ooo.0o0.ooo/2017/05/22/5922ea5a0edce.png" alt="3"><br>这个检验过程十分简单粗暴，就是将Serial前两个字节与0x3334比较，就是说前两个字节为43的Serial都能成功注册<br>于是我修改flag寄存器，使跳转不发生，果然提示我成功了，but….<br><img src="https://ooo.0o0.ooo/2017/05/22/5922eb8ad9bf2.png" alt="4"><br>就在我点击确定之后准备收工并感叹如此简单粗暴之时，突然地一撇，上面灰色的字仍然提醒未注册，555…原来还留了一手哇<br>第一反应是紧接着下面的那个可疑的函数00401130，可能是个校验函数，还需要跟进去看看</p>
<hr>
<p>5.函数00401130<br>这个函数先检测eax是否为0，如果为零则正常退出，若不为零，则在00401145-00401155进行一次循环，将指定内存的值与2C异或又放回去，循环1F次<br><img src="https://ooo.0o0.ooo/2017/05/22/592307ee59e52.png" alt="5"><br>循环后，乱码变成了失败信息，失败的信息会替换掉注册成功的信息，这是为了防止之前的爆破<br><img src="https://ooo.0o0.ooo/2017/05/22/592305d24f9f7.png" alt="6"><br>所以最后再整理整理思路：<br>1）我们可以直接输入以43开头的Serial<br>2）可以把00401121处的跳转nop掉，这样无论如何eax都会被置零<br>3）可以把0040112A处改成mov eax,0，这样无论判断成不成功eax都会置零</p>
]]></content>
      <tags>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP套接字编程</title>
    <url>/2016/11/07/tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>虽然整个TCP套接字编程实现过程比较复杂，不过貌似有相对固定的套路哇。<br>下面是我用C语言实现一个基于TCP协议的单用户客户端跟服务器的连接和数据交互及处理的过程的小程序。</p>
<a id="more"></a>
<p><img src="https://ooo.0o0.ooo/2016/11/08/5821a076b11f2.png" alt="测试结果"></p>
<p>客户端通过读入服务器端的IP连接到服务器，连接成功后服务器端显示客户端的IP和端口号，并返回一条欢迎信息给客户端；<br>客户端能循环从命令行读入数据，服务器循环接受客户端的数据并显示，进行反转处理后返回到客户端，客户端显示返回的数据；<br>当客户端输入”quit”时，服务器端和客户端都关闭连接并退出<br>具体实现的代码如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/*Server.c*/</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;//write，read函数</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;  //send，recv函数</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;  //socket函数</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt; //套接字地址结构</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt; //ip地址转换函数</span></span><br><span class="line"><span class="comment">#include &lt;strings.h&gt; //字节操纵</span></span><br><span class="line"><span class="comment">#define PORT 1234</span></span><br><span class="line"><span class="comment">#define BACKLOG 100</span></span><br><span class="line">void handle(int connectfd, struct sockaddr_in client);<span class="regexp">//</span>自定义的数据处理函数</span><br><span class="line">int main(void)&#123;</span><br><span class="line">  int listenfd, connectfd;</span><br><span class="line">  struct sockaddr_in server;</span><br><span class="line">  struct sockaddr_in client;</span><br><span class="line">  int sin_size;</span><br><span class="line">  int num;</span><br><span class="line">  char buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((listenfd=socket(AF_INET, SOCK_STREAM, <span class="number">0</span>))==-<span class="number">1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;Create socket failed&quot;</span>);</span><br><span class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">  &#125;    <span class="regexp">//</span>打开tcp套接字接口</span><br><span class="line">      </span><br><span class="line">  int opt =<span class="number">1</span>;</span><br><span class="line">  setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); <span class="regexp">//</span>地址复用</span><br><span class="line">        </span><br><span class="line">  bzero(&amp;server, sizeof(server)); <span class="regexp">//</span>地址结构初始化</span><br><span class="line">  server.sin_family = AF_INET;  <span class="regexp">//i</span>pv4协议类型</span><br><span class="line">  server.sin_port = htons(PORT);  <span class="regexp">//</span>端口转换为网络字节</span><br><span class="line">  server.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="regexp">//</span>网络字节的<span class="number">32</span>位ipv4地址，系统自选</span><br><span class="line">        </span><br><span class="line">  <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;server, sizeof(struct sockaddr))==-<span class="number">1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;Bind error&quot;</span>);</span><br><span class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="regexp">//</span>绑定地址结构</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (listen(listenfd, BACKLOG) == -<span class="number">1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="regexp">//</span>设置监听模式</span><br><span class="line">     </span><br><span class="line">  sin_size = sizeof(struct sockaddr_in);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((connectfd = accept(listenfd, (struct sockaddr *)&amp;client, &amp;sin_size)) == -<span class="number">1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">      <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="regexp">//</span>接受连接请求</span><br><span class="line">    handle(connectfd, client);</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">0</span>);   </span><br><span class="line">  &#125; <span class="regexp">//</span>循环接受连接       </span><br><span class="line">  close(listenfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void handle(int connectfd, struct sockaddr_in client) &#123;</span><br><span class="line">  int num,i;</span><br><span class="line">  char recvbuf[<span class="number">100</span>], sendbuf[<span class="number">100</span>];</span><br><span class="line">  printf(<span class="string">&quot;you get a connection from %s\n&quot;</span>, inet_ntoa(client.sin_addr));  </span><br><span class="line">  printf(<span class="string">&quot;The port of connection is %d\n&quot;</span>,htons(client.sin_port));</span><br><span class="line">  send(connectfd,<span class="string">&quot;Welcome to me,I am a server!\n&quot;</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">    num = recv(connectfd,recvbuf,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    recvbuf[num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    printf(<span class="string">&quot;Received message: %s\n&quot;</span>,recvbuf);</span><br><span class="line">    <span class="keyword">if</span>(strcmp(recvbuf,<span class="string">&quot;quit\0&quot;</span> ) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i &lt; num ; i++)  sendbuf[i] = recvbuf[num-i-<span class="number">1</span>];</span><br><span class="line">        sendbuf[num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        send(connectfd, sendbuf, num, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close(connectfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/*Client*/</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt; </span></span><br><span class="line"><span class="comment">#include &lt;strings.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netdb.h&gt;</span></span><br><span class="line"><span class="comment">#define PORT 1234</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  <span class="regexp">//</span>运行时所带参数的个数；存放着每个参数的内容</span><br><span class="line">&#123;</span><br><span class="line">  int fd, numbytes;</span><br><span class="line">  char sendbuf[<span class="number">100</span>],recvbuf[<span class="number">100</span>];</span><br><span class="line">  struct  hostent *he;   <span class="regexp">//g</span>ethostname返回结构体</span><br><span class="line">  struct sockaddr_in server;</span><br><span class="line">        </span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">    printf(<span class="string">&quot;Usage: %s  (IP address)\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">  &#125;  <span class="regexp">//</span>对传入的参数进行判断</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((he = gethostbyname(argv[<span class="number">1</span>])) == NULL) &#123;</span><br><span class="line">    perror(<span class="string">&quot;gethostbyname error.&quot;</span>);</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="regexp">//</span>解析服务器信息</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == -<span class="number">1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Create socket failed.&quot;</span>);</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="regexp">//</span>打开套接字接口</span><br><span class="line">         </span><br><span class="line">  bzero(&amp;server, sizeof(server));  <span class="regexp">//</span>初始化结构地址</span><br><span class="line">  server.sin_family = AF_INET;</span><br><span class="line">  server.sin_port = htons(PORT);</span><br><span class="line">  server.sin_addr = *((struct in_addr *) he-&gt;h_addr);   <span class="regexp">//</span>强制转换指针类型，因为要取值所以*取左</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(fd, (struct sockaddr *)&amp;server, sizeof(struct sockaddr)) == -<span class="number">1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;connect failed.&quot;</span>);</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;  <span class="regexp">//</span>建立三次握手</span><br><span class="line">  numbytes = recv(fd, sendbuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">  sendbuf[numbytes] =<span class="string">&#x27;\0&#x27;</span>;<span class="regexp">//</span>必须使用结束符，否则指针出现错误</span><br><span class="line">  printf(<span class="string">&quot;%s\n&quot;</span>,sendbuf);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      char d[<span class="number">100</span>]=<span class="string">&quot;quit&quot;</span>;</span><br><span class="line">    printf(<span class="string">&quot;please input your world:&quot;</span>);</span><br><span class="line">    gets(recvbuf);</span><br><span class="line">    send(fd,recvbuf,strlen(recvbuf),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(strcmp(recvbuf,d)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    numbytes = recv(fd, sendbuf, <span class="number">100</span>, <span class="number">0</span>);     </span><br><span class="line">       <span class="keyword">if</span>(numbytes == -<span class="number">1</span>)  &#123;</span><br><span class="line">      printf(<span class="string">&quot;recv error.&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    sendbuf[numbytes] =<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    printf(<span class="string">&quot;you get a message: %s\n\n&quot;</span>,sendbuf);</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">  return <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络编程</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现RSA加密解密</title>
    <url>/2016/11/19/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<p>这其实是我们专业上学期的密码学程序设计的一个选题，用C语言实现RSA加密解密并显示出详细的过程，下面的代码就是我写出来，不算简洁，在DOS界面输出包括了：<br>（1）输出了奇数的产生过程，一个介于2^10-2^11，一个介于2^16-2^17；<br>（2）输出了用小于1000以内的素数去试除的判断过程，并输出每次试除之后的余数；<br>（3）Miller-Rabin概率检测算法运行5次，输出检测过程及结果；<br>（4）如果不是奇素数，输出下一个奇数产生的规则；<br>（5）输出辗转相除法返回的参数d；<br>（6）输出模重复平方法返回的密文；<br>（7）输出平方乘算法返回的明文；</p>
<a id="more"></a>
<h5 id="整个流程图："><a href="#整个流程图：" class="headerlink" title="整个流程图："></a>整个流程图：</h5><p><img src="https://ooo.0o0.ooo/2017/02/23/58ae4c9fb5e3f.png" alt="0"></p>
<h5 id="最终的效果图："><a href="#最终的效果图：" class="headerlink" title="最终的效果图："></a>最终的效果图：</h5><p>以“32655”为例<br><img src="https://ooo.0o0.ooo/2017/02/23/58ae4d54eb02d.png" alt="1"><br>由于输出界面的行数有限，所以我只截取了部分。<br>下面是通过了试除法的大素数进入Miller-Rabin概率检测<br><img src="https://ooo.0o0.ooo/2017/02/23/58ae4d9d38c06.png" alt="2"><br>当通过了试除法和Miller-Rabin概率检测之后将会被选中，然后生成符合要求的两个大素数。<br>接下来就是进入下一个阶段，得到大素数p和q之后，计算n和yn<br><img src="https://ooo.0o0.ooo/2017/02/23/58ae4dc135651.png" alt="3"><br>然后通过辗转相除法求乘法逆元，即求解密指数d<br><img src="https://ooo.0o0.ooo/2017/02/23/58ae4dd3602fa.png" alt="4"><br>加密过程采用的是模重复计算法<br><img src="https://ooo.0o0.ooo/2017/02/23/58ae4de057022.png" alt="5"><br>紧接着就是解密过程，采用的是另一种算法–平方乘算法<br><img src="https://ooo.0o0.ooo/2017/02/23/58ae4dedeafdf.png" alt="6"><br>从以上的结果可以看出，该程序逻辑是正确的，因为可以得到最初需要加密的明文。</p>
<h5 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;math.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;stdlib.h&gt; </span><br><span class="line">#<span class="keyword">include</span> &lt;time.h&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> NUM = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a * b % n</span></span><br><span class="line"><span class="comment">//例如: b = 1011101那么a * b mod n = (a * 1000000 mod n + a * 10000 mod n + a * 1000 mod n + a * 100 mod n + a * 1 mod n) mod n </span></span><br><span class="line">long <span class="built_in">int</span> <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">long</span> <span class="params">int</span> <span class="params">a</span>, <span class="params">long</span> <span class="params">int</span> <span class="params">b</span>, <span class="params">long</span> <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    long <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (res + a) % n;</span><br><span class="line">        a = (a + a) % n;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a^b % n</span></span><br><span class="line">long <span class="built_in">int</span> <span class="keyword">mod</span><span class="constructor">_exp(<span class="params">long</span> <span class="params">int</span> <span class="params">a</span>,<span class="params">long</span> <span class="params">int</span> <span class="params">b</span>, <span class="params">long</span> <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    long <span class="built_in">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">res</span>, <span class="params">a</span>, <span class="params">n</span>)</span>;</span><br><span class="line">        a = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">a</span>, <span class="params">a</span>, <span class="params">n</span>)</span>; </span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Miller-Rabin概率检测算法</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">MillerRabin(<span class="params">long</span> <span class="params">int</span> <span class="params">i</span>)</span> &#123;</span><br><span class="line">    long <span class="built_in">int</span> x, pre, u;</span><br><span class="line">    <span class="built_in">int</span> n, j, k = <span class="number">0</span>;</span><br><span class="line">    u = i - <span class="number">1</span>;    <span class="comment">//要求x^u % n</span></span><br><span class="line">    <span class="keyword">while</span>(!(u&amp;<span class="number">1</span>)) &#123;    <span class="comment">//如果u为偶数则u右移，用k记录移位数</span></span><br><span class="line">        k++; u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    srand((long <span class="built_in">int</span>)time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">0</span>; n &lt; <span class="number">5</span>; ++n) &#123;    <span class="comment">//进行5次测试</span></span><br><span class="line">        x = rand<span class="literal">()</span>%(i-<span class="number">2</span>) + <span class="number">2</span>;    <span class="comment">//在[2, i-1)中取随机数</span></span><br><span class="line">        printf(<span class="string">&quot;取随机数x：%ld\n&quot;</span>,x);</span><br><span class="line">        <span class="keyword">if</span>((x%i)<span class="operator"> == </span><span class="number">0</span>)    continue;</span><br><span class="line">        x = <span class="keyword">mod</span><span class="constructor">_exp(<span class="params">x</span>, <span class="params">u</span>, <span class="params">i</span>)</span>;    <span class="comment">//先计算(x^u) % n，</span></span><br><span class="line">        printf(<span class="string">&quot;x^i-1(mod i) = %ld\n&quot;</span>,x);</span><br><span class="line">        pre = x;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; k; ++j) &#123;    <span class="comment">//把移位减掉的量补上，并在这地方加上二次探测</span></span><br><span class="line">            x = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">x</span>, <span class="params">x</span>, <span class="params">i</span>)</span>;</span><br><span class="line">            printf(<span class="string">&quot;x^2(mod i) = %ld\n&quot;</span>,x);</span><br><span class="line">            <span class="keyword">if</span>(x<span class="operator"> == </span><span class="number">1</span><span class="operator"> &amp;&amp; </span>pre != <span class="number">1</span><span class="operator"> &amp;&amp; </span>pre != i-<span class="number">1</span>)    return(<span class="number">0</span>);    <span class="comment">//二次探测定理，这里如果x = 1则pre 必须等于 1，或则 n-1否则可以判断不是素数</span></span><br><span class="line">            pre = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="number">1</span>)    return(<span class="number">0</span>);    <span class="comment">//费马小定理</span></span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;该数通过Miller-Rabin素性概率检测！\n&quot;</span>);</span><br><span class="line">    return(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生第一个在2^10到2^11之间的大奇素数</span></span><br><span class="line"><span class="built_in">int</span> number1<span class="literal">()</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> primenumbers<span class="literal">[<span class="number">167</span>]</span>;</span><br><span class="line">    <span class="built_in">int</span> p=<span class="number">0</span>,i,j,t=<span class="number">0</span>,flag;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">3</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>,flag=<span class="number">1</span>,t;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag!=<span class="number">0</span>) &#123;primenumbers<span class="literal">[<span class="identifier">t</span>]</span> = i;t++;&#125;</span><br><span class="line">    &#125;<span class="comment">//primenumbers[1000]中存放的是1000以内的小素数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1025</span>,t=<span class="number">0</span>;i &lt; <span class="number">2048</span>;i = i+<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//for(i = 2001,t=0;i &lt; 2048;i = i+2)&#123;</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>,flag=<span class="number">1</span>;j &lt; <span class="number">167</span>;j++)&#123;</span><br><span class="line">            printf(<span class="string">&quot;%d/%d的余数：%d\n&quot;</span>,i,primenumbers<span class="literal">[<span class="identifier">j</span>]</span>,i%primenumbers<span class="literal">[<span class="identifier">j</span>]</span>);</span><br><span class="line">            <span class="keyword">if</span>(i%primenumbers<span class="literal">[<span class="identifier">j</span>]</span><span class="operator"> == </span><span class="number">0</span>) &#123;flag=<span class="number">0</span>;printf(<span class="string">&quot;%d不符合，生成下一个\n&quot;</span>,i);break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">&quot;******************************************************\n&quot;</span>);</span><br><span class="line">        printf(<span class="string">&quot;现在是Miller-Rabin概率检测的过程~~~~~\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag=<span class="number">1</span>) &#123;</span><br><span class="line">            t = <span class="constructor">MillerRabin(<span class="params">i</span>)</span>;<span class="comment">//用Miller-Rabin概率检测算法检测</span></span><br><span class="line">            <span class="keyword">if</span>(t != <span class="number">0</span>) &#123;</span><br><span class="line">                p = i;</span><br><span class="line">                printf(<span class="string">&quot;第一个大奇素数是:%d\n&quot;</span>, i);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> printf(<span class="string">&quot;%d不符合，生成下一个\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//用1000以内的小素数试除</span></span><br><span class="line">    return(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生第二个在2^16到2^17之间的大奇素数</span></span><br><span class="line"><span class="built_in">int</span> number2<span class="literal">()</span>&#123;</span><br><span class="line">    long <span class="built_in">int</span> primenumbers<span class="literal">[<span class="number">167</span>]</span>;</span><br><span class="line">    long <span class="built_in">int</span> i,j,q=<span class="number">0</span>,flag,t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">3</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>,flag=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag!=<span class="number">0</span>) &#123;primenumbers<span class="literal">[<span class="identifier">t</span>]</span> = i;t++;&#125;</span><br><span class="line">    &#125;<span class="comment">//primenumbers[1000]中存放的是1000以内的小素数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">65537</span>;i &lt; <span class="number">131072</span>;i = i+<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>,flag=<span class="number">1</span>;j &lt; <span class="number">167</span>;j++)&#123;</span><br><span class="line">            printf(<span class="string">&quot;%ld/%d的余数：%d\n&quot;</span>,i,primenumbers<span class="literal">[<span class="identifier">j</span>]</span>,i%primenumbers<span class="literal">[<span class="identifier">j</span>]</span>);</span><br><span class="line">            <span class="keyword">if</span>(i%primenumbers<span class="literal">[<span class="identifier">j</span>]</span><span class="operator"> == </span><span class="number">0</span>) &#123;flag=<span class="number">0</span>;printf(<span class="string">&quot;%ld不符合，生成下一个\n&quot;</span>,i);break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">&quot;******************************************************\n&quot;</span>);</span><br><span class="line">        printf(<span class="string">&quot;现在是Miller-Rabin概率检测的过程~~~~~\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag=<span class="number">1</span>) &#123;</span><br><span class="line">            t = <span class="constructor">MillerRabin(<span class="params">i</span>)</span>;<span class="comment">//用Miller-Rabin概率检测算法检测</span></span><br><span class="line">            <span class="keyword">if</span>(t != <span class="number">0</span>) &#123;</span><br><span class="line">                q = i;</span><br><span class="line">                printf(<span class="string">&quot;第二个大奇素数是:%ld\n\n\n&quot;</span>, i);</span><br><span class="line">                printf(<span class="string">&quot;******************************************************\n\n&quot;</span>);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> printf(<span class="string">&quot;%ld不符合，生成下一个\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//用1000以内的小素数试除</span></span><br><span class="line">    return(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//辗转相除法求乘法逆元，即求解密指数d </span></span><br><span class="line">long <span class="built_in">int</span> extend(<span class="built_in">int</span> n,<span class="built_in">int</span> b) &#123; </span><br><span class="line">    <span class="built_in">int</span> q,r,r1=n,r2=b,t,t1=<span class="number">0</span>,t2=<span class="number">1</span>,i=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(r2&gt;<span class="number">0</span>) &#123; </span><br><span class="line">        q=r1/r2; </span><br><span class="line">        r=r1%r2; </span><br><span class="line">        r1=r2; </span><br><span class="line">        r2=r; </span><br><span class="line">        t=t1-q*t2; </span><br><span class="line">        t1=t2; </span><br><span class="line">        t2=t; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(t1&gt;=<span class="number">0</span>)  return t1%n; </span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="keyword">while</span>((t1+i*n)&lt;<span class="number">0</span>) i++; </span><br><span class="line">        return t1+i*n; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//模重复计算法</span></span><br><span class="line">void <span class="constructor">RepeatCalculationMethodSquare(<span class="params">__int64</span> <span class="params">a</span>[],<span class="params">unsigned</span> <span class="params">__int64</span> <span class="params">b</span>[],<span class="params">int</span> <span class="params">bin</span>[],<span class="params">int</span> <span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt;= NUM;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bin<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span><span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//a[i+1] = a[i]*b[i]% ;</span></span><br><span class="line">            <span class="comment">//b[i+1] = b[i]*b[i]%n;</span></span><br><span class="line">            a<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>]</span> = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">a</span>[<span class="params">i</span>], <span class="params">b</span>[<span class="params">i</span>], <span class="params">n</span>)</span>; </span><br><span class="line">            b<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>]</span> = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">b</span>[<span class="params">i</span>], <span class="params">b</span>[<span class="params">i</span>], <span class="params">n</span>)</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>]</span> = a<span class="literal">[<span class="identifier">i</span>]</span>%n;</span><br><span class="line">            <span class="comment">//b[i+1] = b[i]*b[i]%n;</span></span><br><span class="line">            b<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>]</span> = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">b</span>[<span class="params">i</span>], <span class="params">b</span>[<span class="params">i</span>], <span class="params">n</span>)</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i-<span class="number">1</span> &gt;= <span class="number">0</span>) printf(<span class="string">&quot;i=%d,k=%d,a[%d]=%I64d,b[%d]=%I64u\n&quot;</span>,i-<span class="number">1</span>,bin<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>,i-<span class="number">1</span>,a<span class="literal">[<span class="identifier">i</span>]</span>,i,b<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;通过模重复计算法求的密文是:%I64d\n&quot;</span>,a<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">    k=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//平方乘算法</span></span><br><span class="line">void <span class="constructor">MultiplyMethodSquare(<span class="params">unsigned</span> <span class="params">__int64</span> <span class="params">a</span>[],<span class="params">__int64</span> <span class="params">b</span>[],<span class="params">int</span> <span class="params">bin</span>[],<span class="params">int</span> <span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">int</span> j = NUM-<span class="number">1</span>;</span><br><span class="line">     unsigned __int64 y;</span><br><span class="line">     <span class="keyword">for</span>(;j &gt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(bin<span class="literal">[<span class="identifier">j</span>]</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                  <span class="comment">//y=a[i-1]*a[i-1]%n;</span></span><br><span class="line">                  <span class="comment">//a[i]=y*b[k]%n;</span></span><br><span class="line">                  y = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">a</span>[<span class="params">i</span>-1], <span class="params">a</span>[<span class="params">i</span>-1], <span class="params">n</span>)</span>; </span><br><span class="line">                  a<span class="literal">[<span class="identifier">i</span>]</span> = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">y</span>, <span class="params">b</span>[<span class="params">k</span>], <span class="params">n</span>)</span>; </span><br><span class="line">              &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="comment">//a[i]=a[i-1]*a[i-1]%n;</span></span><br><span class="line">                 a<span class="literal">[<span class="identifier">i</span>]</span> = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">a</span>[<span class="params">i</span>-1], <span class="params">a</span>[<span class="params">i</span>-1], <span class="params">n</span>)</span>; </span><br><span class="line">              printf(<span class="string">&quot;i=%d,k= %d,a[%d]=%I64u\n&quot;</span>,i,bin<span class="literal">[<span class="identifier">j</span>]</span>,i,a<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(bin<span class="literal">[<span class="identifier">j</span>]</span>==<span class="number">1</span>) a<span class="literal">[<span class="identifier">i</span>]</span>=a<span class="literal">[<span class="identifier">i</span>]</span>*a<span class="literal">[<span class="identifier">i</span>]</span>*b<span class="literal">[<span class="identifier">k</span>]</span>%n;</span><br><span class="line">             <span class="keyword">else</span> <span class="comment">//a[i]=a[i]*a[i]%n;</span></span><br><span class="line">                 a<span class="literal">[<span class="identifier">i</span>]</span> = <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">a</span>[<span class="params">i</span>], <span class="params">a</span>[<span class="params">i</span>], <span class="params">n</span>)</span>; </span><br><span class="line">              printf(<span class="string">&quot;i=%d,k=%d,a[%d]=%I64u\n&quot;</span>,i,bin<span class="literal">[<span class="identifier">j</span>]</span>,i,a<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          j--;</span><br><span class="line">      &#125;</span><br><span class="line">     printf(<span class="string">&quot;通过平方乘算法求的明文为:%I64u\n&quot;</span>,a<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void <span class="constructor">Binary(<span class="params">long</span> <span class="params">int</span> <span class="params">m</span>,<span class="params">int</span> <span class="params">bin</span>[])</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> tmp;<span class="comment">//临时变量表示m模2的余数</span></span><br><span class="line">      <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">        tmp = m%<span class="number">2</span>;</span><br><span class="line">        bin<span class="literal">[NUM]</span> = tmp;</span><br><span class="line">        m = m/<span class="number">2</span>;</span><br><span class="line">        NUM++; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main<span class="literal">()</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> e=<span class="number">17</span>;</span><br><span class="line">    <span class="built_in">int</span> i,p,binary<span class="literal">[<span class="number">1000</span>]</span>,b<span class="literal">[<span class="number">1000</span>]</span>=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    long <span class="built_in">int</span> q,yn,n,d;</span><br><span class="line">    unsigned __int64 m<span class="literal">[<span class="number">1000</span>]</span>,a<span class="literal">[<span class="number">1000</span>]</span>;</span><br><span class="line">    __int64 c<span class="literal">[<span class="number">1000</span>]</span>;</span><br><span class="line">    <span class="comment">//m[0]=32655555;</span></span><br><span class="line">    c<span class="literal">[<span class="number">0</span>]</span>=<span class="number">1</span>;</span><br><span class="line">    a<span class="literal">[<span class="number">0</span>]</span>=<span class="number">1</span>;</span><br><span class="line">    printf(<span class="string">&quot;请输入要加密的内容：&quot;</span>);</span><br><span class="line">    scanf(<span class="string">&quot;%ld&quot;</span>,&amp;m<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">    printf(<span class="string">&quot;******************************************************\n&quot;</span>);</span><br><span class="line">    <span class="comment">//生成大奇素数过程</span></span><br><span class="line">    printf(<span class="string">&quot;现在是生成大奇素数的过程~~~~~\n&quot;</span>);</span><br><span class="line">    printf(<span class="string">&quot;******************************************************\n&quot;</span>); </span><br><span class="line">    p = number1<span class="literal">()</span>;</span><br><span class="line">    q = number2<span class="literal">()</span>;</span><br><span class="line">    printf(<span class="string">&quot;生成两个大素数分别为p=%d(保密),q=%ld(保密)\n&quot;</span>,p,q);       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求n,yn的过程</span></span><br><span class="line">    printf(<span class="string">&quot;\n******************************************************\n&quot;</span>); </span><br><span class="line">    printf(<span class="string">&quot;现在是求模数n和欧拉函数yn的过程~~~~~\n&quot;</span>);</span><br><span class="line">    printf(<span class="string">&quot;******************************************************\n&quot;</span>);</span><br><span class="line">    n = p*q;</span><br><span class="line">    yn = (p-<span class="number">1</span>)*(q-<span class="number">1</span>);</span><br><span class="line">    printf(<span class="string">&quot;n = %d*%ld = %ld\n&quot;</span>,p,q,n );</span><br><span class="line">    printf(<span class="string">&quot;yn = (%d-1)*(%ld-1) = %ld\n&quot;</span>,p,q,yn);</span><br><span class="line">    printf(<span class="string">&quot;求的模数n=%ld(公开),欧拉函数yn=%ld(保密)\n&quot;</span>,n,yn);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//辗转相乘法求d的过程</span></span><br><span class="line">    printf(<span class="string">&quot;\n******************************************************\n&quot;</span>); </span><br><span class="line">    d = extend(yn,e); </span><br><span class="line">    printf(<span class="string">&quot;e*d(mod yn) = %ld\n&quot;</span>,d); </span><br><span class="line">    printf(<span class="string">&quot;求的加密指数e=%ld(公钥,公开),解密指数d=%d(私钥,保密)\n\n&quot;</span>,e,d); </span><br><span class="line">    printf(<span class="string">&quot;******************************************************\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//加密过程</span></span><br><span class="line">    printf(<span class="string">&quot;现在是加密过程~~~~~\n&quot;</span>);</span><br><span class="line">    printf(<span class="string">&quot;******************************************************\n&quot;</span>); </span><br><span class="line">    <span class="constructor">Binary(<span class="params">e</span>,<span class="params">binary</span>)</span>;</span><br><span class="line">    printf(<span class="string">&quot;加密指数e的二进制:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">4</span>;i&gt;=<span class="number">0</span>;i--) printf(<span class="string">&quot;%d&quot;</span>,binary<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="constructor">RepeatCalculationMethodSquare(<span class="params">c</span>,<span class="params">m</span>,<span class="params">binary</span>,<span class="params">n</span>)</span>;</span><br><span class="line">    printf(<span class="string">&quot;\n******************************************************\n&quot;</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解密过程</span></span><br><span class="line">    printf(<span class="string">&quot;现在是解密过程~~~~~\n&quot;</span>);</span><br><span class="line">    printf(<span class="string">&quot;******************************************************\n&quot;</span>);</span><br><span class="line">    <span class="constructor">Binary(<span class="params">d</span>,<span class="params">b</span>)</span>;</span><br><span class="line">    printf(<span class="string">&quot;解密指数d的二进制：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=NUM-<span class="number">1</span>;i&gt;<span class="number">4</span>;i--) printf(<span class="string">&quot;%d&quot;</span>,b<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="constructor">MultiplyMethodSquare(<span class="params">a</span>,<span class="params">c</span>,<span class="params">b</span>,<span class="params">n</span>)</span>;</span><br><span class="line">    printf(<span class="string">&quot;\n******************************************************\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调试过程中也碰到很多问题"><a href="#调试过程中也碰到很多问题" class="headerlink" title="调试过程中也碰到很多问题"></a>调试过程中也碰到很多问题</h5><p>问题1：关于全局变量。用全局变量NUM控制加密指数和解密指数转化成二进制之后存在数组中的最终下标，而没有意识到d的二进制位数的起始下标已经不是0了。<br>解决方法：由于加密指数e是给定的，所以我们可以确定e的二进制数一共会占多少位。所以d的起始下标也就是一个已知的确定的数。</p>
<p>问题2：Miller-Rabin素性概率检测的正确率不够高。<br>解决方法：百度，然后找到一个定理，能提高Miller测试的效率。二次探测定理：如果p是奇素数，则 x2 ≡ 1(mod p)的解为 x = 1 || x = p - 1(mod p);可以利用二次探测定理在实现Miller-Rabin上添加一些细节来提高一些准确率。</p>
<p>问题3：模重复算法和平方乘算法都不能正常的运行，每一步出来的结果都是很大的负数。<br>解决方法：后来把单个的函数拖出来另外测试，包括又把信安数学基础的课本拿出来翻了几遍之后，发现是两个函数中涉及到存储每一步结果的数组没有初始化，而且这两个数组的第一项都应该是1，修改之后果然就正确了。</p>
<p>问题4：同样是关于全局变量的问题。在加密解密的最开始我准备把e和d的二进制都输出，这样就可以与下面的模重复算法和平方乘算法过程中的每一步都对应起来，也可以有一个检查作用，但是由于是NUM全局变量的原因，导致解密指数d的二进制一直都不对。<br>解决方法：考虑过是不是数组没有初始化导致原有的值输出导致的错误，也考虑过是不是转换成二进制的函数写的有问题。在问题一解决的同时，这个问题也解决了，把d的二进制数组的起始下标改正之后就能正确输出了。</p>
<p>问题5：在解密的过程中只有前两步的结果是正确的，后面的a[i]中的值都变成了一大串负数。<br>解决方法：其实提前就意识到了可能会出现这个问题，因为明文加密之后，产生的密文很明显在数值上比明文大很多，所以很可能数值超过范围导致结果不正确。后来修改了一下算法中的式子，把整式拆分成了两步进行，在一定程度上缓解了数值的累积，我把平方乘算法中的a[i]= a[i-1]<em>a[i-1] *b[k]%n 拆分成了y=a[i-1]*a[i-1]%n  +  a[i]=y</em>b[k]%n  。之后解密结果就能正确输出了。</p>
<p>问题6：VC中数据类型问题，我发现因为RSA中涉及到的都是大数字，所以必然会存在超出数值范围的情况，然后产生很多不可计的后果。<br>解决方法：我最开始写代码的时候没有想那么多，我用的数据类型大多数都是int类型，直到后来出现很多问题，我才想到换成long int，long int在VC环境中的长度只有四个字节，然而在部分地方用到的数字还是可能会超过long int 的长度。所以后面就想到用long long int或者unsigned __int64或者double。不过在VC6.0中没有long long int，VC中unsigned __int64和double都是八个字节的长度。</p>
<h5 id="至今还存在的问题"><a href="#至今还存在的问题" class="headerlink" title="至今还存在的问题"></a>至今还存在的问题</h5><p>问题：还是数值范围的问题。<br>想法：我知道在这个课题中最需要解决的问题就是数值超出范围的问题，于是我专门测试了我的程序中可以正确被加密和解密的最大数值，是67568646。超过67568646的数值可能在运算过程中的某些中间值会超出VC环境中无符号整型的范围导致结果的错误。<br>我想过如果要真正意义上的解决大数值问题，应该是将一个大整型拆分成一个一个的数字存放在数组中，不过这是个初步的想法，实行起来可能整个代码都需要大改。我深入想过一点点，还是没有相通就算拆分放在数组中表示一个数，但是中间运算过程中涉及的中间值如果超出范围又该怎么办？<br>所以我打算将这个问题记在小本子上，打算在以后的学习中能找到解决的方法。</p>
]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>内嵌补丁</title>
    <url>/2017/02/10/%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81/</url>
    <content><![CDATA[<p>一个非常小的patchme.exe，修改加密后的字符串</p>
<a id="more"></a>
<p>运行后的界面是这样的<br><img src="https://ooo.0o0.ooo/2017/02/01/58916bb81145b.png" alt="0"><br><img src="https://ooo.0o0.ooo/2017/02/01/58916bbe13923.png" alt="1"><br>用OD打开，单步跟踪，发现第一个异或解密<br>第一次解密区域是004010F5-00401248，与44异或<br><img src="https://ooo.0o0.ooo/2017/02/01/589183e433778.png" alt="2"><br>进入紧接着的函数中，又发现了两次异或解密<br>第二次解密区域是00401007-00401085，与7异或<br>第三次解密区域是004010F5-00401248，与11异或<br><img src="https://ooo.0o0.ooo/2017/02/01/589184a0007f8.png" alt="3"><br><img src="https://ooo.0o0.ooo/2017/02/01/589184a4b5140.png" alt="4"><br>紧接着进入下一个函数，看到一个校验和值的过程<br>校验区域是004010F5-00401246，最后将edx中的和值对比，如果相等就跳转到可以到达OEP的地方，如果不相等就提示错误。<br><img src="https://ooo.0o0.ooo/2017/02/01/5891865e00046.png" alt="5"><br>校验和值之后又有一次异或解密<br>第四次解密区域是0040124A-00401279，与17异或<br><img src="https://ooo.0o0.ooo/2017/02/01/589186344ce7a.png" alt="6"><br>进入OEP之后，看到关键的调用函数DialogBoxParam，查查资料之后第四个参数值得进去看看<br><img src="https://ooo.0o0.ooo/2017/02/01/5891869c0613a.png" alt="7"><br><img src="https://ooo.0o0.ooo/2017/02/01/589186a0667c6.png" alt="8"><br>果然进去004010F5之后就能看到关键的字符串啦<br><img src="https://ooo.0o0.ooo/2017/02/01/58918736549f6.png" alt="9"></p>
<p>现在这里总结下：<br>总共有三个区域分别进行了解密，其中004010F5-00401248解密了两次，而且校验区域也是这个区域，那么猜测重要的字符串肯定就在这个区域内，后来也证实了确实是这样。整理下关键的数据：<br>第一次解密区域是004010F5-00401248，与44异或<br>第二次解密区域是00401007-00401085，与7异或<br>第三次解密区域是004010F5-00401248，与11异或<br>校验区域是004010F5-00401246<br>第四次解密区域是0040124A-00401279，与17异或<br>OEP地址：0040121E<br>第一个字符串起始地址：0040110A<br>第二个字符串起始地址：00401123<br>因为需要修改的区域要验证和值，所以内嵌一段代码比较方便，查看一下PE文件有没有什么空的位置可以插入代码：<br><img src="https://ooo.0o0.ooo/2017/02/01/589188e05ad29.png" alt="10"><br>第一区段在磁盘上的大小是400，在虚拟大小是280，所以可以在280-400之间插入代码，看下进程的入口是00401000，所以可以知道在OD中修改的位置在00401280，插入内嵌补丁<br><img src="https://ooo.0o0.ooo/2017/02/01/5891897e25bc4.png" alt="11"><br>因为这个区域没有解密过程，自然也不存在加密状态，所以不需要修改，最后一句代码是跳转到OEP，接下来要做的是原来直接跳转到OEP那句代码修改成跳转到00401280<br><img src="https://ooo.0o0.ooo/2017/02/01/589189f328f36.png" alt="12"><br>不过突然发现00401083这里是要经过第二次解密的，所以需要修改成异或7之后的二进制<br><img src="https://ooo.0o0.ooo/2017/02/01/58918a532e86f.png" alt="13"><br>然后保存文件，重命名为finished.exe<br>接下来试试修改结果，运行一下<br><img src="https://ooo.0o0.ooo/2017/02/01/58918a9197468.png" alt="14"><br><img src="https://ooo.0o0.ooo/2017/02/01/58918a95251b8.png" alt="15"><br>成功，啦啦啦<del>~</del><br>这个简单的例子，我真得来来去去弄了好久，但是真的发现很有趣<br>之前学习PE文件的时候真的头晕眼花，看了好几天拖了好几天，但是后面看到Upack文件什么的，就觉得很好玩，那些大牛作者太厉害了，脑洞大开</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>PE</tag>
        <tag>Unpack</tag>
      </tags>
  </entry>
  <entry>
    <title>以notepad_upx.exe为例了解UPX文件</title>
    <url>/2017/01/27/%E4%BB%A5notepad_uxp%E4%B8%BA%E4%BE%8B%E4%BA%86%E8%A7%A3uxp%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>刚了解了PE文件相关的姿势，下面是以使用upx压缩器压缩XP SP3中的notepad.exe后得到的PE文件为例了解UPX文件<br>网上有很多特殊技巧脱壳，很实用也很快哒<br>之前我用的最多的就是ESP定律，但一直也不太清楚原理，这次终于了解了一些啦，我先用ESP定律脱壳，然后再跟踪分析</p>
<a id="more"></a>
<p>先用PEid看一下，确实是加上了upx的壳<br><img src="https://ooo.0o0.ooo/2017/01/31/589015c38e1b1.png" alt="0"></p>
<h5 id="特殊技巧脱壳–ESP定律"><a href="#特殊技巧脱壳–ESP定律" class="headerlink" title="特殊技巧脱壳–ESP定律"></a>特殊技巧脱壳–ESP定律</h5><p><img src="https://ooo.0o0.ooo/2017/01/31/5890186f526fb.png" alt="1"><br>选中要下断点的那行，依次选择断点 -&gt; 硬件访问 -&gt; Word<br>执行到断点处停下，删掉硬件断点<br><img src="https://ooo.0o0.ooo/2017/01/31/58901a16b7e23.png" alt="2"><br>单步执行，很快就看到一个向上的大跳转，鸡冻！跳上去应该就是OEP啦<br><img src="https://ooo.0o0.ooo/2017/01/31/58901a48730b7.png" alt="3"><br>可以确定这就是真正的入口了。因为可以看到首先调用了GetModuleHandle函数获取模块的基准位置，然后又比较了“MZ”“PE”。<br><img src="https://ooo.0o0.ooo/2017/01/31/58901a8f14b2f.png" alt="4"></p>
<h5 id="跟踪分析UPX文件"><a href="#跟踪分析UPX文件" class="headerlink" title="跟踪分析UPX文件"></a>跟踪分析UPX文件</h5><p>首先看看pushad的时候各寄存器的状态<br><img src="https://ooo.0o0.ooo/2017/01/31/58901d3c22647.png" alt="5"><br>先执行Animate命令跟踪代码，看到了一个循环，停下看看在干啥。手速太慢，停下来的时候都不知道已经执行多少次啦。先下个断点重新执行一次，看di的起始值是多少才能确定这个循环的目的。<br><img src="https://ooo.0o0.ooo/2017/01/31/58901e3882ed8.png" alt="6"><br><img src="https://ooo.0o0.ooo/2017/01/31/589020c5143c3.png" alt="7"></p>
<h6 id="第一个循环"><a href="#第一个循环" class="headerlink" title="第一个循环"></a>第一个循环</h6><p>循环次数36B，将dx指向的内容搬到di指向的中去，di的最初值是1001，刚好第一个节区的起始地址是1000，继续跟踪，换成单步跟踪，突然发现animate over有些快，一下子跑没了，呜呜。。。<br><img src="https://ooo.0o0.ooo/2017/01/31/5890296aa17d7.png" alt="8"></p>
<h6 id="第二个循环"><a href="#第二个循环" class="headerlink" title="第二个循环"></a>第二个循环</h6><p>单步跟了两圈，发现这是一个大循环，在0101534E-010153FD之间。因为将第一个循环包含在其中了，所以猜想这个大循环很有可能是还原第一个节区的重要解压缩过程。<br>跳出循环看看结果验证一下，刚刚跟踪的时候撇了一眼di=01001372这个值，就对比循环前后这里是否被填充，因为这个地址刚好是在第一节区内<br><img src="https://ooo.0o0.ooo/2017/01/31/58903694cb7c5.png" alt="9"><br><img src="https://ooo.0o0.ooo/2017/01/31/589036a549b65.png" alt="10"><br>可以看到被写入了内容。所以初步断定这里是还原第一节区解压的过程，因为太菜，所以只能猜测，等过段时间有进步了再回来具体分析代码。</p>
<h6 id="第三个循环"><a href="#第三个循环" class="headerlink" title="第三个循环"></a>第三个循环</h6><p><img src="https://ooo.0o0.ooo/2017/01/31/5890373f4949a.png" alt="11"></p>
<h6 id="第四个循环"><a href="#第四个循环" class="headerlink" title="第四个循环"></a>第四个循环</h6><p>发现循环Loadlibrary，GetProcAddr函数入栈，其实不言而喻，两个函数是为了在文件解密完成后对原始文件重建IAT表。<br><img src="https://ooo.0o0.ooo/2017/01/31/5890377fa98e3.png" alt="12"><br>在循环下面不远处就看到popad，对比pushad那时候的寄存器状态发现是一样的，然后跳转到oep的代码已经在眼前了<br><img src="https://ooo.0o0.ooo/2017/01/31/58903849d702f.png" alt="13"><br>虽然只是很粗略的跟踪分析了一下，不过还是觉得学习到很多，也粗略的可以解释下esp定律啦。以这个例子中的upx壳为例。<br>类似堆栈帧，在到达真正的入口之前要将寄存器的状态还原，所以利用pushad和popad，因为popad要访问栈的8个dword，那么我们只要在其中一个字节，字或双字下个硬件访问断点就行了，f9运行，跟着f8到遇到返回或jmp，跟着就到达oep了。</p>
<h4 id="简单总结下"><a href="#简单总结下" class="headerlink" title="简单总结下"></a>简单总结下</h4><p><img src="https://ooo.0o0.ooo/2017/01/31/589020c5143c3.png" alt="7"><br> PEview看了下，发现加壳后，第一二节区的名字改了，第一节区在磁盘文件的大小为0，但在内存上是有大小的，所以很有可能是解压时将内容写入第一节区。<br> 还能看到入口地址在00015330，属于第二节区，所以EP和解压代码都在第二节区<br> 资源节区貌似变化不大</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>PE</tag>
        <tag>Unpack</tag>
      </tags>
  </entry>
  <entry>
    <title>一个有意思的Crackme6</title>
    <url>/2017/05/15/%E5%88%86%E6%9E%90Crackme6/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>这个CM有一些防打补丁的措施，或许对作者来说多些检测就能使CM更难被破解一些把，分析起来也稍微增加了一丢丢小麻烦</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：Crackme6.exe</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>PEid，OD</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>1.运行界面<br>是一个很直白的绿色窗口，要求输入password，如果输入错误会在输入密码的界面显示ACCESS DENIED!<br><img src="https://ooo.0o0.ooo/2017/05/22/5922d00980b97.png" alt="2"></p>
<hr>
<p>2.查壳<br>显示没有加壳</p>
<hr>
<p>3.查找关键的API<br>在找到的模块间的调用,在GetDlgItem和GetDlgItemTextA处下断，因为要获取填入的密码必然要调用这两个API</p>
<hr>
<p>4.第一层检测<br><img src="https://ooo.0o0.ooo/2017/05/22/5922a91185d4a.png" alt="0"><br>第一层显示检测了密码的长度是否大于10或者是否为空，以及最后的一个关键函数的返回值<br>如果只是想爆破的话，只需要把0040129F处的跳转nop掉或者0040129D处改成xor eax，eax就行，不能改成mov eax,0，否则会把下面的代码覆盖掉</p>
<hr>
<p>5.进入00401421函数<br><img src="https://ooo.0o0.ooo/2017/05/22/5922d6fe68929.png" alt="1"><br>首先eax所指向的地址中用户存有输入的密码，所以当ecx为零的时候[ecx+eax]指向的是用户输入的密码<br>0040142D-0040143E 将密码的前四个字节和1234567异或，第一个字节在和E与运算；循环的第二遍是将后面四个字节和1234567异或，第五个字节在和E与运算<br>00401442-0040144C 这里有两种情况，第一种如果密码长度大于10或者为空，穿进来的第二个参数都是1，所以这个循环只会进行一次，也就是将密码的第九个字节内存中的值加上密码第一个字节的值；第二种情况就是循环密码长度次，也就是将密码的第九个字节内存中的值加上密码每一个字节的值，可能也是因为要遍历每一个字节，所以限制密码长度不能超过10吧<br>00401450-0040146F 过程与前两个循环相似，就不具体解释了<br>然后来到第一个检测点，如果这里跳转，eax则不会得到重置，从而使得外层的检测失败提示错误信息</p>
<p><img src="https://ooo.0o0.ooo/2017/05/22/5922c2d26829f.png" alt="2"><br>然后继续向下分析，突然发现很有意思的事情，接下来的代码中充斥着很多的检测跳转，我也有些疑惑作者的用意了<br>后面又紧接着7个检测点。<br>0）在第一个检测之前有一个循环，这个循环也挺有趣，将dl循环置零九次，难道是作者写错了吗？不太明白<br>1）将紧接在用户输入密码后的第一个内存中的值与EEEE异或，然后与30AC比较<br>2）密码第一个字节放低八位，第二个字节高八位，加上3592后与E59A比较<br>3）前四个字节与7A81B008比较<br>4）将dl中的值四次与A异或，循环结束后结果还是dl原始值，密码后面四个字节与388DBF02比较<br>5）将dl，cl置零，将第六个字节与BF比较<br>6）将第七个字节与8D比较<br>7）将第六个字节与BF比较<br>经历完这重重检测之后，eax才会得到置零，才能顺利的得到好的结果<br>为什么作者要写这么多检测呢？甚至还重复的？我看到有人说是为了防打补丁，可是我觉得如果真的要打补丁爆破的话，直接在第一层修改一个地方就可以了。<br>不过也可能作者觉得越多的检测越能防止被破解吧。<br>这些过多的检测说不定给我提供了更多的信息去找到一个正确的key呢。</p>
<hr>
<p>6.我真的认真想过要找出一个正确的key，但好绕哦，还是没找出来。</p>
<hr>
<p>小结：<br>这个CM是我目前碰到过最多检测，算法也比较绕的了。<br>如果只是分析算法，我觉得还行，可是要找出一组key的话，我觉得还是有难度的。<br>哦对了，在最后突然想起来我看到到大佬说过，多余的检测可能是软件检测程序是否被打补丁被修改，因为如果是正确的注册码，那么势必所有的检测都能通过，但如果前面的通过了而后面的没有通过，那很有可能就是程序被修改，所以可能后面检测没有通过的跳转就是跳转到一个绕绕绕的地方迷惑逆向工程师，从而使破解的难度大大的增大。<br>也通过这个cm让我眼界又开阔了很多呢</p>
]]></content>
      <tags>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title>分析Tut.ReverseMe1</title>
    <url>/2017/02/01/%E5%88%86%E6%9E%90Tut_ReverseMe1/</url>
    <content><![CDATA[<p>第一个目标：去除消息框<br>第二个目标：查找注册码</p>
<a id="more"></a>
<p>先运行看看,先弹出长的消息框，确定后弹出regcode的消息框，若随便输入，提示错误信息“Sorry,wrong registration code”；若点击Nag？，就又会弹出第一个消息框<br><img src="https://ooo.0o0.ooo/2017/01/15/587a60d8694e9.png" alt="0"></p>
<p>【One】这里要去除点击Nag？后的消息框<br>要弹出消息框，肯定会调用api，刚好abex’crackme#2也是VB文件，分析的时候又刚好查了下VB函数中rtcMsgBox有这个功能，那我就先把所有调用的地方都下断点，逐个击破<br><img src="https://ooo.0o0.ooo/2017/01/15/587a61cf9ce69.png" alt="1"><br>第一个调用的地方连最初的消息框都还没弹出来，NO<br>第二个调用的地方在我点击Nag?之后没反应了，NO<br>运行到第三个调用的地方就直接弹出来了，YES，就是这里了<br>怎么设法让这里不调用呢？要先知道这个函数有几个参数，直接清理栈的话后面要带多大的数，跟进去看看发现可以修改成add esp,14<br><img src="https://ooo.0o0.ooo/2017/01/15/587a6717cc6f9.png" alt="2"><br>结果提示不能正常运行，我太菜了，可能有些细节没有改到位嘛<br><img src="https://ooo.0o0.ooo/2017/01/15/587a67795465d.png" alt="3"><br>只有换种思路了，VB文件貌似都是通过点击按钮触发事件，所以如果直接不调用点击Nag？按钮之后的模块，可能也能达到去除消息框的目的，然后我向上找哇找，只为看到那一抹熟悉的栈帧代码，呀，然后继续去搜寻带了几个参数，先看堆栈信息<br><img src="https://ooo.0o0.ooo/2017/01/15/587a6a80ee5cd.png" alt="4"><br>去到调用它的地方看看，果然看到了想要的信息<br><img src="https://ooo.0o0.ooo/2017/01/15/587a6aa545339.png" alt="5"><br>直接将push ebp修改成retn 4<br><img src="https://ooo.0o0.ooo/2017/01/15/587a6acf021d5.png" alt="6"><br>目标一完成，哦耶！</p>
<p>【two】<br>随便填一个123456，还是先从错误信息“Sorry,wrong registration code”入手<br><img src="https://ooo.0o0.ooo/2017/01/15/587a6b77dc85d.png" alt="7"><br>还是在正确错误代码上面找关键跳转，可以从VB函数看出关键的比较，在比较之前压栈了两个变量，其中一个去堆栈区看，竟然是我们输入的，那么另一个变量值I’mlena151极有可能就是正确的注册码，我去试试看<br><img src="https://ooo.0o0.ooo/2017/01/15/587a6ca4b6378.png" alt="8"><br>哦耶，成功，I’mlena151就是正确的注册码<br><img src="https://ooo.0o0.ooo/2017/01/15/587a6d5d4cb47.png" alt="9"></p>
]]></content>
      <tags>
        <tag>Crack</tag>
        <tag>学习笔记</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>域名解析编程</title>
    <url>/2016/11/28/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>下面是我用C语言实现域名解析的小程序。</p>
<a id="more"></a>
<p><img src="https://ooo.0o0.ooo/2016/11/13/582870e864eeb.png" alt="测试结果"></p>
<p>这个小程序能根据命令行输入的IP或域名完成解析，并打印出域名解析结果。</p>
<p>具体实现的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>  *<span class="title">he</span>,*<span class="title">host</span>;</span></span><br><span class="line">    <span class="keyword">char</span> **alias;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)  &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage :%s name | IP&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    argv++;</span><br><span class="line">    <span class="keyword">for</span>(; *argv != <span class="literal">NULL</span>; argv++)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (inet_aton( *argv, &amp;addr.sin_addr) != <span class="number">0</span>) &#123;</span><br><span class="line">            he = gethostbyaddr((<span class="keyword">char</span> *)&amp;addr.sin_addr, <span class="keyword">sizeof</span> (addr), AF_INET);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;address information of IP %s:\n&quot;</span>, *argv);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            he = gethostbyname(*argv);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;address information of host %s:\n&quot;</span>, *argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (he == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no address information of %s\n&quot;</span>,*argv);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Officaial host name: %s\n&quot;</span>, he-&gt;h_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name aliases:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(alias=he-&gt;h_aliases;*alias != <span class="number">0</span>;alias++) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *alias);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nIP addresses: &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, inet_ntoa( *(struct in_addr *)he-&gt;h_addr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络编程</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>并发多线程服务器编程</title>
    <url>/2016/11/20/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>下面是我用C语言实现采用多线程并发服务器技术，服务器可以同时接受多个客户的请求的小程序。</p>
<a id="more"></a>
<p><img src="https://ooo.0o0.ooo/2016/11/11/5825c0d0a4a32.png" alt="测试结果"></p>
<p>PS:在编译服务器端程序的时候，由于用到的库不是Linux自带的，所以有些特殊，在这里我用的是：<br>gcc -D_REENTRANT thread_server.c -o thread_client -lpthread</p>
<p>客户端通过读入服务器端的IP连接到服务器，连接成功后服务器端显示客户端的IP、端口号和名字，并返回一条欢迎信息给客户端；<br>客户端能循环从命令行读入数据，服务器循环接受客户端的数据并显示，进行反转处理后返回到客户端，客户端显示返回的数据；<br>当客户端输入”quit”时，服务器端和客户端都关闭连接并退出<br>具体实现的代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*server.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PORT    1234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  BACKLOG    10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> connectfd,struct sockaddr_in client)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ARG</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connectfd;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ARG</span>    *<span class="title">arg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>, <span class="title">client</span>;</span></span><br><span class="line">      <span class="keyword">int</span> sin_size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((listenfd=socket(AF_INET, SOCK_STREAM, <span class="number">0</span>))==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;Create socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;    <span class="comment">//打开tcp套接字接口</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">int</span> opt =<span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt)); <span class="comment">//地址复用</span></span><br><span class="line">        </span><br><span class="line">    bzero(&amp;server, <span class="keyword">sizeof</span>(server)); <span class="comment">//地址结构初始化</span></span><br><span class="line">    server.sin_family = AF_INET;  <span class="comment">//ipv4协议类型</span></span><br><span class="line">    server.sin_port = htons(PORT);  <span class="comment">//端口转换为网络字节</span></span><br><span class="line">    server.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">//网络字节的32位ipv4地址，系统自选</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="comment">//绑定地址结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, BACKLOG) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="comment">//设置监听模式</span></span><br><span class="line">     </span><br><span class="line">    sin_size = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((connectfd = accept(listenfd, (struct sockaddr *)&amp;client, &amp;sin_size)) == <span class="number">-1</span>) &#123;</span><br><span class="line">             perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="comment">//接受连接请求</span></span><br><span class="line">        arg = (struct ARG*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(client));</span><br><span class="line">        arg -&gt; connfd = connectfd;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)&amp;arg -&gt; client, &amp;client, <span class="keyword">sizeof</span>(client));</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid, <span class="literal">NULL</span>,function, (<span class="keyword">void</span> *)arg))&#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread create error!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> connectfd,struct sockaddr_in client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num,i;</span><br><span class="line">    <span class="keyword">char</span> recvbuf[<span class="number">100</span>], sendbuf[<span class="number">100</span>], client_name[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you get a connection from %s\n&quot;</span>, inet_ntoa(client.sin_addr));  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The port of connection is %d\n&quot;</span>,htons(client.sin_port));</span><br><span class="line">        send(connectfd,<span class="string">&quot;Welcome to me,I am a server!\n&quot;</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    num = recv(connectfd, client_name,<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">close</span>(connectfd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client disconnected.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    client_name[num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client name is %s.\n&quot;</span>,client_name);</span><br><span class="line">    <span class="keyword">while</span> (num = recv(connectfd, recvbuf,<span class="number">100</span>,<span class="number">0</span>))&#123;</span><br><span class="line">        recvbuf[num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received client (%s) message: %s\n&quot;</span>, client_name, recvbuf);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; num ; i++)  sendbuf[i] = recvbuf[num-i<span class="number">-1</span>];</span><br><span class="line">        sendbuf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        send(connectfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(connectfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ARG</span> *<span class="title">info</span>;</span></span><br><span class="line">    info = (struct ARG *)arg;</span><br><span class="line">    handle(info -&gt; connfd, info -&gt; client);</span><br><span class="line">        <span class="built_in">free</span>(arg);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*client.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT            1234</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> connecfed,<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  <span class="comment">//运行时所带参数的个数；存放着每个参数的内容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd,connectfd;</span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">100</span>],recvbuf[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">hostent</span> *<span class="title">he</span>;</span>   <span class="comment">//gethostname返回结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s  &lt;IP address&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;  <span class="comment">//对传入的参数进行判断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((he = gethostbyname(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;gethostbyname error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="comment">//解析服务器信息</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Create socket failed.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125; <span class="comment">//打开套接字接口</span></span><br><span class="line">         </span><br><span class="line">    bzero(&amp;server, <span class="keyword">sizeof</span>(server));  <span class="comment">//初始化结构地址</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line">    server.sin_addr = *((struct in_addr *) he-&gt;h_addr);   <span class="comment">//强制转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connectfd=<span class="built_in">connect</span>(fd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect failed.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;  <span class="comment">//建立三次握手</span></span><br><span class="line">        </span><br><span class="line">    handle(<span class="built_in">stdin</span>,fd);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> connectfd,<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">100</span>],recvbuf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    num = recv(fd, sendbuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    sendbuf[num] =<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//必须使用结束符，否则指针出现错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,sendbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your name:&quot;</span>);</span><br><span class="line">    gets(sendbuf);</span><br><span class="line">    send(fd,sendbuf,<span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;please input your world:&quot;</span>);</span><br><span class="line">        gets(recvbuf);</span><br><span class="line">        send(fd,recvbuf,<span class="built_in">strlen</span>(recvbuf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(recvbuf,<span class="string">&quot;quit&quot;</span>)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        num = recv(fd, sendbuf, <span class="number">100</span>, <span class="number">0</span>);     </span><br><span class="line">           <span class="keyword">if</span>(num == <span class="number">-1</span>)  &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv error.&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">//接受服务器发来的字符串</span></span><br><span class="line">        sendbuf[num] =<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//必须使用结束符，否则指针出现错误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;you get a message: %s\n\n&quot;</span>,sendbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络编程</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>分析abex&#39;crackme#2</title>
    <url>/2017/01/23/%E5%88%86%E6%9E%90abex&#39;cm2/</url>
    <content><![CDATA[<p>好兴奋，这次涉及了简单的加密过程。第一个涉及加密的小程序abex’crackme#2我来也~</p>
<a id="more"></a>
<p>运行abex’crackme#2,从运行结果可以得出几个信息：一个字符串“Nope，this serial is wrong!”，输入的Name不能少于4 chars，还有这个程序编写于1999-9-19.<br>从界面看，是个生成序列号的小程序。比abex’crackme#1长的更像普遍的Crackme，以前见过的也差不多都是注册码这类。但是不知道是根据name生成序列号，还是指定的name和序列号进行对比。<br><img src="https://ooo.0o0.ooo/2017/01/14/587a2d510e7b0.png" alt="0"></p>
<p>不过不管是哪一种，应该都会有一个关键的比较然后跳转，所以先搜索得到的那个提示错误的字符串，去附近找找跳转的代码<br><img src="https://ooo.0o0.ooo/2017/01/14/587a35fdbb721.png" alt="1"><br>从错误信息像上面找，看了到提示正确的信息，虽然我破解的小程序不多，但是我见过的关键跳转都在正确和错误代码的上面不远处。看到距离最近的JE上面有个函数，查了一下VB函数（根据前面的msvbvm60就能知道这是一个典型的VB文件），_vbavertsteq是一个比较两个变量值是否相等的函数，在这里下一个断点之后运行程序，我输入的name是1111，serial是2222<br><img src="https://ooo.0o0.ooo/2017/01/14/587a387d56a14.png" alt="2"><br>既然_vbavertsteq是一个关键的判断函数，那么它前面两个push的寄存器就值得关注了，作为参数压栈，推测这两个值有一个是我输入的1111，另一个很有可能就是name为1111对应的正确的序列号。<br>在数据窗口跟随这两个地址，哇塞，立马就蹦出了两个字符串，刚好其中一个就是1111，那么另一个真的是正确的序列号吗？我打开abex’crackme#2输入试了试，果然就是！edx中存储的是正确序列号对应的地址。<br><img src="https://ooo.0o0.ooo/2017/01/14/587a41c31250d.png" alt="3"><br>如果只是简单的暴破的话，到这里就可以啦。因为不管输入什么name，都可以直接得出生成的正确序列号。<br>我又用2222试了试，序列号是96969696，发现这个小程序采用的是第二种，根据name生成序列号，而且生成的序列号很有规律。那么肯定在判断之前有一个对name处理生成序列号的过程，虽然我还很菜，但还是想继续分析下去，要是以我的目前水平搞不定的话，那就过几天再来<br>根据1111 → 95959595，2222 → 96969696，我觉得加密过程应该比较简单明了，推测是对每一位字符进行处理，而不是对整个字符串进行处理，所以肯定会有一个循环。<br>往上面找寻据加密过程，发现有一个循环过程，但还不确定是否为加密过程，先下个断点，继续向上，看到了熟悉的字符串，是提醒name不能小于4 chars的提示，那么在向上肯定能看到读取name中字符串的过程代码，再向上发现了眼熟的栈帧代码，那就从这里开始分析吧。在单步调试过程中看到字符串“check”，猜测这个过程是点击check按钮后的整个过程。到达这一步，发现name中字符串已经读取完成，保存在[ebp-88]中<br><img src="https://ooo.0o0.ooo/2017/01/15/587a4e6e59740.png" alt="4"><br>在保存了name之后，又读取了name字符串的长度保存在[ebp-D4]中，后来又存在ebx中。下面的截图就是加密过程了，首先从字符串特定位置取出一个字符<br><img src="https://ooo.0o0.ooo/2017/01/15/587a55af246b8.png" alt="5"><br>间接把64存入edi，用字符的ascii码加上64之后，eax返回结果<br><img src="https://ooo.0o0.ooo/2017/01/15/587a55f6d11ed.png" alt="6"><br>然后讲两个变量值连接在一起，最后循环<br><img src="https://ooo.0o0.ooo/2017/01/15/587a5647c3c32.png" alt="7"><br>总结一下整个触发check后的过程：读取name和serial中的的字符串–读取name字符串的长度–循环加密（取出一个字符-ascii码加64-把加密后字符串连接在一起-循环）–判断ax和dx中地址对应值是否相等（ax返回结果）–ax等于零则提示错误；ax等于&amp;Hffff则提示成功。</p>
<p>完工收队，哦耶！纯弱鸡的分析，我是按照我自己的理解和自己建立的概念去分析的，过程中肯定有一些错误和侥幸，以后学习更多知识了之后再回来修正。</p>
]]></content>
      <tags>
        <tag>Crack</tag>
        <tag>学习笔记</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>并发多进程服务器编程</title>
    <url>/2016/11/15/%E5%B9%B6%E5%8F%91%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>下面是我用C语言实现采用多进程并发服务器技术，服务器可以同时接受多个客户的请求的小程序。</p>
<a id="more"></a>
<p><img src="https://ooo.0o0.ooo/2016/11/11/5825be8c6c106.png" alt="测试结果"></p>
<p>客户端通过读入服务器端的IP连接到服务器，连接成功后服务器端显示客户端的IP、端口号和名字，并返回一条欢迎信息给客户端；<br>客户端能循环从命令行读入数据，服务器循环接受客户端的数据并显示，进行反转处理后返回到客户端，客户端显示返回的数据；<br>当客户端输入”quit”时，服务器端和客户端都关闭连接并退出<br>具体实现的代码如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/*server.c*/</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt; </span></span><br><span class="line"><span class="comment">#include &lt;strings.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netdb.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#define  PORT    1234</span></span><br><span class="line"><span class="comment">#define  BACKLOG    10</span></span><br><span class="line"></span><br><span class="line">void handle(int connectfd, struct sockaddr_in client);</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int listenfd, connectfd;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    struct sockaddr_in    server, client;</span><br><span class="line">    int sin_size;</span><br><span class="line">    <span class="keyword">if</span>((listenfd=socket(AF_INET, SOCK_STREAM, <span class="number">0</span>))==-<span class="number">1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;Create socket failed&quot;</span>);</span><br><span class="line">        <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    int opt = SO_REUSEADDR;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</span><br><span class="line">    bzero(&amp;server, sizeof(server));</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line">    server.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;server, sizeof(server))==-<span class="number">1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind error&quot;</span>);</span><br><span class="line">        <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, BACKLOG) == -<span class="number">1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sin_size = sizeof(struct sockaddr_in);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((connectfd = accept(listenfd, (struct sockaddr *)&amp;client, &amp;sin_size)) == -<span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">            <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span> ((pid=fork())&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            close(connectfd);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            close(listenfd);</span><br><span class="line">            handle(connectfd, client);</span><br><span class="line">            <span class="keyword">exit</span>(<span class="number">0</span>);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            printf(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);      </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void handle(int connectfd, struct sockaddr_in client)&#123;</span><br><span class="line">    int num,i;</span><br><span class="line">    char recvbuf[<span class="number">100</span>], sendbuf[<span class="number">100</span>], client_name[<span class="number">100</span>];</span><br><span class="line">    printf(<span class="string">&quot;you get a connection from %s\n&quot;</span>, inet_ntoa(client.sin_addr));  </span><br><span class="line">    printf(<span class="string">&quot;The port of connection is %d\n&quot;</span>,htons(client.sin_port));</span><br><span class="line">    send(connectfd,<span class="string">&quot;Welcome to me,I am a server!\n&quot;</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    num = recv(connectfd, client_name,<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">        close(connectfd);</span><br><span class="line">        printf(<span class="string">&quot;client disconnected.\n&quot;</span>);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    client_name[num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    printf(<span class="string">&quot;Client name is %s.\n&quot;</span>,client_name);</span><br><span class="line">    <span class="keyword">while</span> (num = recv(connectfd, recvbuf,<span class="number">100</span>,<span class="number">0</span>))&#123;</span><br><span class="line">        recvbuf[num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        printf(<span class="string">&quot;Received client (%s) message: %s\n&quot;</span>, client_name, recvbuf);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; num ; i++)  sendbuf[i] = recvbuf[num-i-<span class="number">1</span>];</span><br><span class="line">        sendbuf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        send(connectfd, sendbuf, strlen(sendbuf), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(connectfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*client.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT            1234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE     100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> connecfed,<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  <span class="comment">//运行时所带参数的个数；存放着每个参数的内容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd,connectfd;</span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">100</span>],recvbuf[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">hostent</span> *<span class="title">he</span>;</span>   <span class="comment">//gethostname返回结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s  &lt;IP address&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;  <span class="comment">//对传入的参数进行判断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((he = gethostbyname(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;gethostbyname error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="comment">//解析服务器信息</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Create socket failed.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="comment">//打开套接字接口</span></span><br><span class="line">         </span><br><span class="line">    bzero(&amp;server, <span class="keyword">sizeof</span>(server));  <span class="comment">//初始化结构地址</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line">    server.sin_addr = *((struct in_addr *) he-&gt;h_addr);   <span class="comment">//强制转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connectfd=<span class="built_in">connect</span>(fd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect failed.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;  <span class="comment">//建立三次握手        </span></span><br><span class="line">    handle(<span class="built_in">stdin</span>,fd);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> connectfd,<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">100</span>],recvbuf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    num = recv(fd, sendbuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    sendbuf[num] =<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//必须使用结束符，否则指针出现错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,sendbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your name:&quot;</span>);</span><br><span class="line">    gets(sendbuf);</span><br><span class="line">    send(fd,sendbuf,<span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;please input your world:&quot;</span>);</span><br><span class="line">        gets(recvbuf);</span><br><span class="line">        send(fd,recvbuf,<span class="built_in">strlen</span>(recvbuf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(recvbuf,<span class="string">&quot;quit&quot;</span>)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        num = recv(fd, sendbuf, <span class="number">100</span>, <span class="number">0</span>);     </span><br><span class="line">           <span class="keyword">if</span>(num == <span class="number">-1</span>)  &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv error.&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="comment">//接受服务器发来的字符串</span></span><br><span class="line">        sendbuf[num] =<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//必须使用结束符，否则指针出现错误</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;you get a message: %s\n\n&quot;</span>,sendbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络编程</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手动删除可执行文件的基址重定位节区</title>
    <url>/2017/02/03/%E6%89%8B%E5%8A%A8%E5%88%A0%E9%99%A4%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%8A%82%E5%8C%BA/</url>
    <content><![CDATA[<p>exe可执行文件，基址重定位表对运行没什么影响。所以删除后也不影响正常运行，而且文件大小将缩减。</p>
<a id="more"></a>
<p>使用工具：PEView，WinHex</p>
<h4 id="1-删除-reloc节区头"><a href="#1-删除-reloc节区头" class="headerlink" title="1.删除.reloc节区头"></a>1.删除.reloc节区头</h4><p>在.reloc节区头可以看到节区头的起始位置和大小，在winhex中全部用0填充<br><img src="https://ooo.0o0.ooo/2017/01/31/589055b90122b.png" alt="0"></p>
<h4 id="2-删除-reloc节区"><a href="#2-删除-reloc节区" class="headerlink" title="2.删除.reloc节区"></a>2.删除.reloc节区</h4><p>在节区头信息中可以看到reloc节区在磁盘文件中的起始位置，因为是最后一个节区，所以把最后所有的数据都用0覆盖<br><img src="https://ooo.0o0.ooo/2017/01/31/5890562a36adf.png" alt="1"><br><img src="https://ooo.0o0.ooo/2017/01/31/589056303d1b8.png" alt="2"></p>
<h4 id="3-修改IMAGE-FILE-HEADER"><a href="#3-修改IMAGE-FILE-HEADER" class="headerlink" title="3.修改IMAGE_FILE_HEADER"></a>3.修改IMAGE_FILE_HEADER</h4><p>把IMAGE_FILE_HEADER中的节区数从5改成4<br><img src="https://ooo.0o0.ooo/2017/01/31/589056b0e71e3.png" alt="3"><br><img src="https://ooo.0o0.ooo/2017/01/31/589056b146aff.png" alt="4"></p>
<h4 id="4-修改IMAGE-OPTIONAL-HEADER"><a href="#4-修改IMAGE-OPTIONAL-HEADER" class="headerlink" title="4.修改IMAGE_OPTIONAL_HEADER"></a>4.修改IMAGE_OPTIONAL_HEADER</h4><p>把IMAGE_OPTIONAL_HEADER中的Image的大小改小，但是要改成多少呢<br>可以看到Section Align为1000，再去看看reloc节区的大小是E40，小于1000，所以直接减去1000<br>在WinHex中把相应位置改成00010000就行了，最后保存，我生成的新文件命名是1.exe<br><img src="https://ooo.0o0.ooo/2017/01/31/589056f29a91c.png" alt="5"><br><img src="https://ooo.0o0.ooo/2017/01/31/589056f2b97d4.png" alt="6"><br><img src="https://ooo.0o0.ooo/2017/01/31/5890573090886.png" alt="7"><br><img src="https://ooo.0o0.ooo/2017/01/31/5890574372090.png" alt="8"></p>
<p>最后我再把修改后的文件拖进PEView中，看到节区数已经变成了4，Size of Image也变成了0001000，没有了基址重定位节区的痕迹了，成功，哦耶！<br>添加，修改节区应该也是类似的方法</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的二进制思想在C语言中</title>
    <url>/2016/12/04/%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%9D%E6%83%B3%E5%9C%A8C%E8%AF%AD%E8%A8%80%E4%B8%AD/</url>
    <content><![CDATA[<p>在前段时间写RSA加密解密算法的时候，看到过一个简单的二进制思想在C语言中的实现，内容大概如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">long <span class="built_in">int</span> <span class="keyword">mod</span><span class="constructor">_mul(<span class="params">long</span> <span class="params">int</span> <span class="params">a</span>, <span class="params">long</span> <span class="params">int</span> <span class="params">b</span>, <span class="params">long</span> <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    long <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = (res + a) % n;</span><br><span class="line">        a = (a + a) % n;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这个函数是用来计算 a * b(mod n)这个计算式的<br>原理是 b = 1011101，那么a * b mod n = (a * 1000000 mod n + a * 10000 mod n + a * 1000 mod n + a * 100mod n + a * 1 mod n) mod n<br>不过因为我C语言很菜，虽然根据一些C语言程序设计的书敲过一些题目练习，不过还没有接触过涉及二进制思想的C语言编程，也从来没有在码代码的时候想过除了最直接的方式实现功能之外还有更高效的实现方法<br>这小小的几行代码算是开拓了我的编程思维，带我又多看到了未知编程世界的一角。路漫漫其修远兮哇<br>所以记录在这里。<br>我想了想，这种方法不仅可以运用在密码学的计算中，例如平方乘算法还有模重复计算法中，还能有效的一定程度的解决编程计算中大数值，特别是中间值是大数值的情况。如果再加以拓展延伸的学习，在程序的优化中可能用处会更大。<br>不过我目前还只是尝试了把这种思想运用在密码学的计算中和一定程度的解决RSA密码算法中中间值是大数值的问题中。</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>C语言</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>线程专用数据TSD编程</title>
    <url>/2016/11/24/%E7%BA%BF%E7%A8%8B%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AETSD%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>下面是我用C语言实现一个有关线程专用数据TSD的小程序。</p>
<a id="more"></a>
<p><img src="https://ooo.0o0.ooo/2016/11/13/582870fe09653.png" alt="测试结果"></p>
<p>客户端通过读入服务器端的IP连接到服务器，连接成功后服务器端显示客户端的IP，端口号和名字，并返回一条欢迎信息给客户端；<br>客户端能循环从命令行读入数据，服务器循环接受客户端的数据并显示，进行反转处理后返回到客户端，客户端显示返回的数据；<br>当客户端输入Ctrl+D时，客户端都关闭连接并退出，在每个用户退出时服务器要显示该用户输入的所有信息。</p>
<p>具体实现的代码如下：<br> <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*server.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PORT    1234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  BACKLOG 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> connectfd,struct sockaddr_in client)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">savedata</span><span class="params">(<span class="keyword">char</span> *recvbuf, <span class="keyword">int</span> len, <span class="keyword">char</span> *cli_data)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ARG</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_key_t</span> key;</span><br><span class="line"><span class="keyword">pthread_once_t</span>  once = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DATA_THR</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destructor</span> <span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">creatkey_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    pthread_key_create (&amp;key, destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>    listenfd, connectfd;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ARG</span>    *<span class="title">arg</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>, <span class="title">client</span>;</span></span><br><span class="line">      <span class="keyword">int</span> sin_size;</span><br><span class="line">    <span class="keyword">if</span>((listenfd=socket(AF_INET, SOCK_STREAM, <span class="number">0</span>))==<span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;Create socket failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;    <span class="comment">//打开tcp套接字接口</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">int</span> opt =<span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt)); <span class="comment">//地址复用</span></span><br><span class="line">        </span><br><span class="line">    bzero(&amp;server, <span class="keyword">sizeof</span>(server)); <span class="comment">//地址结构初始化</span></span><br><span class="line">    server.sin_family = AF_INET;  <span class="comment">//ipv4协议类型</span></span><br><span class="line">    server.sin_port = htons(PORT);  <span class="comment">//端口转换为网络字节</span></span><br><span class="line">    server.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">//网络字节的32位ipv4地址，系统自选</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr))==<span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;Bind error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="comment">//绑定地址结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, BACKLOG) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="comment">//设置监听模式</span></span><br><span class="line">    sin_size = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((connectfd = accept(listenfd, (struct sockaddr *)&amp;client,&amp;sin_size)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="comment">//接受连接请求</span></span><br><span class="line">        arg = (struct ARG*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ARG));</span><br><span class="line">        arg -&gt; connfd = connectfd;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)&amp;arg -&gt; client, &amp;client, <span class="keyword">sizeof</span>(client));</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid, <span class="literal">NULL</span>, function, (<span class="keyword">void</span> *)arg))&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread create error!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> connectfd, struct sockaddr_in client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num,i;</span><br><span class="line">    <span class="keyword">char</span> cli_data[<span class="number">5000</span>],recvbuf[<span class="number">100</span>], buf[<span class="number">100</span>], cli_name[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you get a connection from %s\n&quot;</span>, inet_ntoa(client.sin_addr));  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The port of connection is %d\n&quot;</span>,htons(client.sin_port));</span><br><span class="line">        send(connectfd,<span class="string">&quot;Welcome to me,I am a server!\n&quot;</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    num = recv(connectfd, cli_name, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(connectfd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cllient disconnected.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cli_name[num<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client name is %s\n&quot;</span>,cli_name);</span><br><span class="line">    <span class="keyword">while</span> (num=recv(connectfd,recvbuf,<span class="number">100</span>,<span class="number">0</span>)) &#123;        </span><br><span class="line">        recvbuf[num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received client (%s) message: %s\n&quot;</span>, cli_name, recvbuf);</span><br><span class="line">        savedata( recvbuf, num, cli_data);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; num ; i++) &#123;buf[i] = recvbuf[num-i<span class="number">-1</span>];&#125;</span><br><span class="line">        buf[num]=<span class="string">&#x27;\0&#x27;</span>;        </span><br><span class="line">        send(connectfd, buf,<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(connectfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client(%s) closed connection.\nUser&#x27;s data:%s\n&quot;</span>,cli_name,cli_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ARG</span> *<span class="title">info</span>;</span></span><br><span class="line">    info = (struct ARG *)arg;</span><br><span class="line">    handle(info -&gt; connfd, info -&gt; client);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">savedata</span><span class="params">(<span class="keyword">char</span> *recvbuf, <span class="keyword">int</span> len, <span class="keyword">char</span> *cli_data)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DATA_THR</span> * <span class="title">data</span>;</span></span><br><span class="line">    pthread_once(&amp;once,creatkey_once);</span><br><span class="line">    <span class="keyword">if</span> ((data = (struct DATA_THR *)pthread_getspecific ( key )) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        data = (struct DATA_THR *) <span class="built_in">calloc</span> (<span class="number">1</span>, <span class="keyword">sizeof</span>(struct DATA_THR));</span><br><span class="line">        pthread_setspecific (key, data);</span><br><span class="line">        data -&gt; index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; len <span class="number">-1</span>; i++) cli_data[data -&gt; index++] = recvbuf[i];</span><br><span class="line">        cli_data[data -&gt; index] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*client.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT            1234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE     100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(FILE *fp,<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getMessage</span><span class="params">(<span class="keyword">char</span> *sendbuf,<span class="keyword">int</span> len,FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  <span class="comment">//运行时所带参数的个数；存放着每个参数的内容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd,connectfd;</span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">100</span>],recvbuf[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">hostent</span> *<span class="title">he</span>;</span>   <span class="comment">//gethostname返回结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s  &lt;IP address&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;  <span class="comment">//对传入的参数进行判断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((he = gethostbyname(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;gethostbyname error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="comment">//解析服务器信息</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Create socket failed.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125; <span class="comment">//打开套接字接口</span></span><br><span class="line">         </span><br><span class="line">    bzero(&amp;server, <span class="keyword">sizeof</span>(server));  <span class="comment">//初始化结构地址</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line">    server.sin_addr = *((struct in_addr *) he-&gt;h_addr);   <span class="comment">//强制转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connectfd=<span class="built_in">connect</span>(fd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect failed.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;  <span class="comment">//建立三次握手</span></span><br><span class="line">        </span><br><span class="line">    handle(<span class="built_in">stdin</span>,fd);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(FILE *fp,<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">100</span>],recvbuf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    num = recv(fd, sendbuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    sendbuf[num] =<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//必须使用结束符，否则指针出现错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,sendbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your name:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fgets(sendbuf,<span class="number">100</span>,fp)==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nexit.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    send(fd,sendbuf,<span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(getMessage(sendbuf,<span class="number">100</span>,fp))&#123;</span><br><span class="line">         send(fd,sendbuf,<span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>);</span><br><span class="line">    num=recv(fd,recvbuf,<span class="number">100</span>,<span class="number">0</span>);        </span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nexit.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    recvbuf[num]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;you get a message: %s\n\n&quot;</span>,recvbuf);</span><br><span class="line">        &#125; <span class="comment">//接受服务器发来的字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nexit.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getMessage</span><span class="params">(<span class="keyword">char</span> *sendbuf,<span class="keyword">int</span> len,FILE *fp)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input your world:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>(fgets(sendbuf,<span class="number">100</span>,fp));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络编程</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>静态分析Lab06-04</title>
    <url>/2017/02/28/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Lab604/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>最近在学习IDA的使用，然后分析一个很简单很简单的小文件。</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：Lab06-04.exe<br>MD5：21be74dfafdacaaab1c8d836e2186a69</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>WinMD5，IDA pro</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>1)首先看看Strings<br><img src="https://ooo.0o0.ooo/2017/03/29/58db5bc860caf.png" alt="0"><br>有个网址“<a href="http://www.practicalmalwareanalysis.com/cc.htm%E2%80%9D">http://www.practicalmalwareanalysis.com/cc.htm”</a><br>有个主机迹象“Software\Microsoft\Windows\CurrentVersion\Run”</p>
<p>2)再看看有没有有趣的引入函数<br><img src="https://ooo.0o0.ooo/2017/03/29/58db5d096578d.png" alt="1"><br><img src="https://ooo.0o0.ooo/2017/03/29/58db5d1375021.png" alt="2"><br>有两个关于注册表的函数，很有可能会修改注册表，结合前面看到的字符串，很有可能将本身添加了自启动项。<br>有几个有网络特征的函数，所以后面的分析要注意。</p>
<p>3)进入主函数下面的第一个子过程sub_401000<br><img src="https://ooo.0o0.ooo/2017/03/29/58db60047477c.png" alt="3"><br>调用InternetGetConnectedState函数返回本地网络连接状态，如果有可用的连接就打印成功信息，若返回值为空就打印错误1.1信息。<br>sub_4012B5只有一个参数，而且参数是已“\n”为结尾的字符串，结合两处的代码，应该是printf打印函数，然后将这个过程改名printf方面后面分析。</p>
<p>4)sub_401040<br><img src="https://ooo.0o0.ooo/2017/03/29/58db660660863.png" alt="4"><br>这个过程主要是打开网络连接，然后检测是否能打开“<a href="http://www.practicalmalwareanalysis.com/cc.htm%E2%80%9D">http://www.practicalmalwareanalysis.com/cc.htm”</a> 这个网址，若不能打开就打印错误2.1信息，否则读取这个网页的信息。<br>若不能读取则打印错误2.2信息，否则与‘&lt;!--’比较，不相等则打印错误2.3信息，否则将后一个字符放在al中返回。</p>
<p>5)将从al中返回的值放入了var_8中，然后打印提示信息“Success:Parsad Command is al中的字符”<br><img src="https://ooo.0o0.ooo/2017/03/29/58db685d4eee4.png" alt="5"></p>
<p>6）sub_401150<br><img src="https://ooo.0o0.ooo/2017/03/29/58db6abd55d95.png" alt="6"><br><img src="https://ooo.0o0.ooo/2017/03/29/58db6ac21cf1a.png" alt="7"><br>这个过程中是一个switch结构，还有一个跳转表（00401173处）<br>这个过程的参数仍然是放在al里面的html注释信息，先与‘a’相减，之后再与4做对比，所以这个命令只有在为a,b,c,d或e的时候有对应的过程，否则打印错误信息。下面是我整理的switch结构：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>（var_8）&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:创建目录“<span class="attr">C:</span>\\Temp”;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:将自身复制到“<span class="attr">C:</span>\\Temp\\cc.exe”;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:若有“<span class="attr">C:</span>\\Temp\\cc.exe”这个文件就将它删除;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:打开注册表“Software\\Microsoft\\Windows\\CurrentVe”并将“<span class="attr">C:</span>\\Temp\\cc.exe”作为数据，“Malwaer”作为名称设置值;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:休眠<span class="number">100</span>秒;<span class="keyword">break</span>;</span><br><span class="line">    <span class="symbol">default:</span>打印错误信息;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7）休眠<br><img src="https://ooo.0o0.ooo/2017/03/29/58db6fe808e39.png" alt="8"><br>执行完sub_401150后会休眠一分钟</p>
<p>8）loc_401251是个循环结构，循环次数是1440次。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>这个文件先检测是否有可用的网络连接，没有就打印错误信息并退出。<br>有可用的网络连接打印成功消息，检测是否能打开指定网址，若不能打印错误消息。<br>可打开指定网址，检测是否能读取文件，若不能打印错误消息。<br>若能读取文件，与‘&lt;!--’比较，不相等则打印错误信息。<br>相等则将后一个字符放在al中返回，打印提示信息“Success:Parsad Command is al中的字符”。<br>判断al中的字符是什么，然后做出相应的操作。<br>最后休眠一分钟之后，判断计数器是否大于等于1440，小于则跳到检测是否能打开指定网址继续循环执行。</p>
]]></content>
      <tags>
        <tag>Reverse</tag>
        <tag>病毒分析</tag>
      </tags>
  </entry>
  <entry>
    <title>静态基础分析Lab01-02</title>
    <url>/2016/12/18/%E9%9D%99%E6%80%81%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90Lab0102/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>biubiubiu! 继续使用静态分析基础技术分析第二个样本，虽然可能相比上一个样本会有很多相似之处，但是天下没有两个相同的病毒嘛~~熟能生巧，干起来</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：Lab01-02.exe<br>时间戳：2011-01-19 16:10:41<br>MD5：8363436878404da0ae3e46991e355b83<br>SHA1：5a016facbcb77e2009a01ea5c67b39af209c3fcb</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>WinMD5，Strings，PEid，PEview，dependencywalker，Exeinfo PE，OD</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>首先用360查杀一下，显示发现木马<br><img src="https://ooo.0o0.ooo/2016/12/26/58608cdab456e.png" alt="1"></p>
<p>然后我们把它上传到 <a href="https://www.virustotal.com/">https://www.virustotal.com/</a> 中检测分析<br><img src="https://ooo.0o0.ooo/2016/12/26/58608d04e9a5b.png" alt="2"><br>结果：77.8%的人觉得这是恶意代码，而且我们可以从附加信息中得到它的一些基本信息。</p>
<h5 id="工具：WinMD5"><a href="#工具：WinMD5" class="headerlink" title="工具：WinMD5"></a>工具：WinMD5</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/58608d4f99995.png" alt="3"><br>结果：习惯啦，其实已经获得MD5之后，这一步可以不要</p>
<h5 id="工具：Strings"><a href="#工具：Strings" class="headerlink" title="工具：Strings"></a>工具：Strings</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/58608ed7d06ed.png" alt="4"><br><img src="https://ooo.0o0.ooo/2016/12/26/58608ef65eb36.png" alt="5"><br>结果：排除一些显而易见不重要的字符串，可以看到这些关键的信息。例如：KERNEL32.dll等等，还有一个域名：<a href="http://wareanysisbook.com/">http://wareanysisbook.com</a> ，可见KERNEL32.dll，ADVAPI32.dll,MSVCRT.dll,WININET.dll是其中包含的重要dll，其他的是可能使用到的重要函数。看到WININET.dll，我猜测这个样本肯定有连接网络的迹象，上面的域名可能就是目标地址。根据几个函数也能猜测该样本可能有载入动态链接库，操作进程虚拟地址，创建服务对象，使用http协议联网等行为</p>
<h5 id="工具：PEid，Exeinfo-PE"><a href="#工具：PEid，Exeinfo-PE" class="headerlink" title="工具：PEid，Exeinfo PE"></a>工具：PEid，Exeinfo PE</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/586092347277e.png" alt="6"><br>结果：用PEID查壳是UPX-&gt;<a href="http://www.upx.sourceforge.net*,有壳哇,可以看见是upx壳,但是没有版本信息,我们再换个工具exeinfo/">www.upx.sourceforge.net*，有壳哇，可以看见是upx壳，但是没有版本信息，我们再换个工具Exeinfo</a> PE看看，是upx0.89-3.xx<br><img src="https://ooo.0o0.ooo/2016/12/26/5860b880b516c.png" alt="7"><br>用PEview看看确实有壳<br><img src="https://ooo.0o0.ooo/2016/12/26/5860b8659406a.png" alt="8"></p>
<h5 id="脱壳工具：OD（在这里我用的是ESP定律）"><a href="#脱壳工具：OD（在这里我用的是ESP定律）" class="headerlink" title="脱壳工具：OD（在这里我用的是ESP定律）"></a>脱壳工具：OD（在这里我用的是ESP定律）</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/5860cea9553e9.png" alt="9"><br><img src="https://ooo.0o0.ooo/2016/12/26/5860ced9de995.png" alt="10"><br>跟踪该地址，在该地址下断点，硬件访问断点<br><img src="https://ooo.0o0.ooo/2016/12/26/5860ceedd17dd.png" alt="11"><br>F9运行到断点处之后单步运行，发现有个向上的跳转，所以跳过那里<br><img src="https://ooo.0o0.ooo/2016/12/26/5860cf4c58c04.png" alt="12"><br>然后看到一个大大的jmp跳转，好激动好激动哇，可能马上就要到达OEP了<br><img src="https://ooo.0o0.ooo/2016/12/26/5860cfe0e9959.png" alt="13"><br>这里就是入口点，在这里脱壳，脱壳后发现貌似不用修复，脱壳后的样本我用a来命名了，所以下面的a.exe就是脱壳后的Lab01-02.exe。再用PEid，Exeinfo PE查一下，发现脱壳成功<br><img src="https://ooo.0o0.ooo/2016/12/26/5860d0518b4c4.png" alt="14"></p>
<h5 id="工具：PEview"><a href="#工具：PEview" class="headerlink" title="工具：PEview"></a>工具：PEview</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/5860d413a6e69.png" alt="15"><br>再次看到这个节的信息,猜测是.taxt节，其中虚拟大小和在磁盘的大小相等，表示此时的样本已经没有壳了<br><img src="https://ooo.0o0.ooo/2016/12/26/5860d45527176.png" alt="16"><br>这个节的名字被改了，但是不影响看其中的信息，我猜测是.data节，又看到那个域名地址，可以更进一步的肯定该样本会连接网络与目标地址通信。<br><img src="https://ooo.0o0.ooo/2016/12/26/5860d4be300ad.png" alt="17"><br><img src="https://ooo.0o0.ooo/2016/12/26/5860d4db0bccc.png" alt="18"><br>在.idata节中看到包含的很多很多函数，比之前查找字符串中的多，另一个节也被改名了，我猜测是.rdata节，里面也包含了重要dll和之前在strings中看到的函数</p>
<h5 id="工具：dependencywalker"><a href="#工具：dependencywalker" class="headerlink" title="工具：dependencywalker"></a>工具：dependencywalker</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/5860d59ea46da.png" alt="19"><br><img src="https://ooo.0o0.ooo/2016/12/26/5860d5acb5dfd.png" alt="20"><br><img src="https://ooo.0o0.ooo/2016/12/26/5860d5bdac2ac.png" alt="21"><br><img src="https://ooo.0o0.ooo/2016/12/26/5860d5c9590f0.png" alt="22"><br>结果：我们可以看到Lab01-02.exe的dll列表包含了4个dll，我还是把上面所导入的函数和相应的功能到列在下面，以便推测实现的功能：（虽然已经可以大致猜测出来了）</p>
<p>ADVAPI32.dll CreateService:创建一个服务对象，并将其添加到指定的服务控制管理器数据库的函数。<br>ADVAPI32.dll OpenSCManager:函数建立了一个到服务控制管理器的连接，并打开指定的数据库<br>ADVAPI32.dll StartServiceCtrlDispatcher:负责把程序主线程连接到服务控制管理程序<br>KERNEL32.dll CreateMutex：找出当前系统是否已经存在指定进程的实例。如果没有则创建一个互斥体。<br>KERNEL32.dll CreateThread：该函数在主线程的基础上创建一个新线程<br>KERNEL32.dll CreateWaitableTimer：创建一个可等待的计时器对象<br>KERNEL32.dll ExitPrecess：指定想中断的那个进程的一个退出代码<br>KERNEL32.dll GetModuleFileName：获取当前进程已加载模块的文件的完整路径，该模块必须由当前进程加载<br>KERNEL32.dll OpenMutex：现有的一个已命名互斥体对象创建一个新句柄<br>KERNEL32.dll SetWaitableTimer：可以设置为一个特定的时刻（如December 16, 1999 at 9:45 PM）或者一个相对的时间（如从现在起每五分钟）<br>KERNEL32.dll SystemTimeToFileTime：是一个进程，即系统时间本地时间<br>KERNEL32.dll WaitForSingleObject：当等待仍在挂起状态时，句柄被关闭，那么函数行为是未定义的。该句柄必须具有 SYNCHRONIZE 访问权限。<br>MSVCRT.dll XcptFilter：标识要执行的异常和相关事件<br>MSVCRT.dll getmainargs：调用分析的命令行并复制参数传递给 main() 返回传递的指针<br>MSVCRT.dll _p___initenv：初始化环境变量<br>MSVCRT.dll _p__commode：定默认文件提交模式。函数仅供内部使用，用户代码不应调用它<br>MSVCRT.dll _p__fmode：_p__fmode 函数仅供内部使用，用户代码不应调用它。特定模式的文件。_open_pipe 和 I/O 操作指定 binary 或 text 转换<br>MSVCRT.dll _set_app_type：找不到具体函数功能，猜测是设置应用程序类型。<br>MSVCRT.dll _setusermatherr：指定用户提供的事务来处理算术错误，而不是_matherr事务。<br>MSVCRT.dll adjust_fdiv：找不到具体函数功能，猜测为链接时自动调用的<br>MSVCRT.dll controlfp：获取和设置浮点控制字<br>MSVCRT.dll except_handler3：异常处理函数<br>MSVCRT.dll initterm：内部方法指浏览函数指针表并初始化它们<br>MSVCRT.dll _exit/exit：终止函数。它们之间的区别是_exit函数直接将程序关闭，缓冲区中的数据就会丢失，反之，如果向保证数据的完整性，就一定要使用exit函数。<br>WININET.dll InternetOpen:初始化一个应用程序，以使用 WinINet 函数<br>WININET.dll InternetOpenUrl:额外的头的大小，以TCHAR为单位</p>
<p>猜想该样本创建了一个服务对象，但是服务对象叫什么名字就不知道了。</p>
<h5 id="工具：Strings-1"><a href="#工具：Strings-1" class="headerlink" title="工具：Strings"></a>工具：Strings</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/5860e0a5a2ff9.png" alt="23"><br><img src="https://ooo.0o0.ooo/2016/12/26/5860e0b4c3a25.png" alt="24"></p>
<h6 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h6><p>把脱壳后的文件再次用strings查看一下字符串，果然多了两大段的关键信息，其中一段里面就是我们上面已经列出的函数，另一段中除了函数之外却多出了几个字符串“MalService”和“<a href="http://www.malwareanalysisbook.com/">http://www.malwareanalysisbook.com</a> ”,哦豁，原来是书的作者写的样本哇。仔细对比脱壳之前的 信息，发现被忽略的MalService派上了用场，之前的域名地址也被补充完整。所以在这里我就能推测出创建的新服务对象的名字是MalService。</p>
<h5 id="Lab01-02-exe分析结束了，我最后得出的结论是：这个文件是用VC6-0编译出来的，加了upx壳。它的主要功能是通过调用KERNEL32-dll，MSVCRT-dll，ADVAPI32-dll和WININET-dll来实现。一方面创建名为“MalService”的服务，可能还设置有时间限制；另一方面存在连接网络迹象与域名为“http-www-malwareanalysisbook-com-”的目标地址之间有通信或者说访问这个目标地址。"><a href="#Lab01-02-exe分析结束了，我最后得出的结论是：这个文件是用VC6-0编译出来的，加了upx壳。它的主要功能是通过调用KERNEL32-dll，MSVCRT-dll，ADVAPI32-dll和WININET-dll来实现。一方面创建名为“MalService”的服务，可能还设置有时间限制；另一方面存在连接网络迹象与域名为“http-www-malwareanalysisbook-com-”的目标地址之间有通信或者说访问这个目标地址。" class="headerlink" title="Lab01-02.exe分析结束了，我最后得出的结论是：这个文件是用VC6.0编译出来的，加了upx壳。它的主要功能是通过调用KERNEL32.dll，MSVCRT.dll，ADVAPI32.dll和WININET.dll来实现。一方面创建名为“MalService”的服务，可能还设置有时间限制；另一方面存在连接网络迹象与域名为“http://www.malwareanalysisbook.com ”的目标地址之间有通信或者说访问这个目标地址。"></a>Lab01-02.exe分析结束了，我最后得出的结论是：<u>这个文件是用VC6.0编译出来的，加了upx壳。它的主要功能是通过调用KERNEL32.dll，MSVCRT.dll，ADVAPI32.dll和WININET.dll来实现。一方面创建名为“MalService”的服务，可能还设置有时间限制；另一方面存在连接网络迹象与域名为“<a href="http://www.malwareanalysisbook.com/">http://www.malwareanalysisbook.com</a> ”的目标地址之间有通信或者说访问这个目标地址。</u></h5><p>第一次自己成功脱壳，虽然很简单，但是还是敲级敲级开心~~biubiubiu</p>
]]></content>
      <tags>
        <tag>Unpack</tag>
        <tag>病毒分析</tag>
      </tags>
  </entry>
  <entry>
    <title>破解abex&#39;crackme#1</title>
    <url>/2017/01/18/%E7%A0%B4%E8%A7%A3abex&#39;cm1/</url>
    <content><![CDATA[<p>终于考完试，工程实践也答辩结束啦，又能愉快地嗨起来！下面是尝试用多种方法破解abex’crackme#1</p>
<a id="more"></a>

<p>运行abex’crackme#1，只有一个确定按钮</p>
<p><img src="https://ooo.0o0.ooo/2017/01/14/5879f575496d8.png" alt="0"></p>
<p>点击确定，直接就是提示错误，再次点击确定就退出啦。那就只能暴破了</p>
<p><img src="https://ooo.0o0.ooo/2017/01/14/5879f583f3a22.png" alt="1"></p>
<p>因为刚开始着手学习，所以在暴破之前想先试着分析一下，代码出乎意料的简短，书上说是因为直接使用汇编语言编写的缘故。这个小程序主要检测的是C盘的类型。一个关键的跳转，决定结果是失败还是成功，所以思路可以从这个跳转着手，不管用什么方法，只要可以跳转到成功的那一部分就行了</p>
<p><img src="https://ooo.0o0.ooo/2017/01/14/587a168512a58.png" alt="2"></p>
<p>【One：修改关键的跳转】</p>
<p>如果只是从修改跳转条件入手的话，可以改成无条件跳转到想要的位置</p>
<p><img src="https://ooo.0o0.ooo/2017/01/14/587a18da3d510.png" alt="3"></p>
<p>也可以用有条件跳转，反正肯定是不相等，所以改成不相等则跳转也行</p>
<p><img src="https://ooo.0o0.ooo/2017/01/14/587a18e7cc12d.png" alt="4"></p>
<p>【Two：修改相关的寄存器值】</p>
<p>在上面的分析中可以看到，主要是比较eax和esi中的值，相等就跳转到成功那部分代码，所以修改其中一个寄存器的值，使它们相等就行，我修改的是eax的值。不过书中李承远老师解释的是esi自增了两次为2，所以是把eax中的1和esi中的2相比较貌似是不准确的，因为esi中的值并不是一定会从0开始，或许书中那样写为了让读者理解起来方便才写成2的吧。</p>
<p><img src="https://ooo.0o0.ooo/2017/01/14/587a18f4f3d07.png" alt="5"></p>
]]></content>
      <tags>
        <tag>Crack</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>静态基础分析Lab01-03</title>
    <url>/2016/12/25/%E9%9D%99%E6%80%81%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90Lab0103/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>上一个样本涉及到了简单的脱壳，这个样本也有脱壳处理，走起来<del>我发现这个样本脱壳+分析明显比前之前快很多啦</del>感觉眼看自己在一点点进步哇</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：Lab01-03.exe<br>MD5：9c5c27494c28ed0b14853b346b113145<br>SHA1：290ab6f431f46547db2628c494ce615d6061ceb8</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>Strings，PEid，dependencywalker，OD</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>首先用360查杀一下，显示发现木马，然后查下壳</p>
<h5 id="工具：PEid"><a href="#工具：PEid" class="headerlink" title="工具：PEid"></a>工具：PEid</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/586140f485c78.png" alt="1"><br>结果：用PEID查壳是FSG，有壳哇，还是没听说过的壳，下一步脱壳，百度了脱壳八大法慢慢试出来哒</p>
<h5 id="脱壳工具：OD（在这里我用的是模拟跟踪法）"><a href="#脱壳工具：OD（在这里我用的是模拟跟踪法）" class="headerlink" title="脱壳工具：OD（在这里我用的是模拟跟踪法）"></a>脱壳工具：OD（在这里我用的是模拟跟踪法）</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/586141b6771d1.png" alt="2"><br>载入之后，看节信息，可以看到.rsrc节的地址是405000，所以在命令行输入tc eip&lt;405000<br><img src="https://ooo.0o0.ooo/2016/12/26/586142926b0f6.png" alt="3"><br>Ctral+A之后可以看到，咦，看着好顺眼，已经到达OEP啦，然后脱壳，我脱壳后的文件命名的是b.exe<br><img src="https://ooo.0o0.ooo/2016/12/26/586142e506d06.png" alt="4"><br>再往下拉一下，可以看到call Lab01-03，我什么都不懂，但是感觉这个调用的应该是Lab01-03主函数啦，接下来再查下壳，看脱对了木有<br><img src="https://ooo.0o0.ooo/2016/12/26/5861437955d2d.png" alt="5"><br>嘿嘿，已经显示VC6.0啦，脱壳成功，耶~</p>
<h5 id="工具：Strings"><a href="#工具：Strings" class="headerlink" title="工具：Strings"></a>工具：Strings</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/58614507c64eb.png" alt="6"><br>发现貌似脱壳后的文件PE的节都被改名了，这里可以看到哈哈，还有一丢丢函数，貌似是脱壳前就能看到的函数<br><img src="https://ooo.0o0.ooo/2016/12/26/5861456507706.png" alt="7"><br><img src="https://ooo.0o0.ooo/2016/12/26/586145755e713.png" alt="8"><br>结果：接下来两张截图里面也是一些函数和dll信息，还有一个在Lab01-02里面也出现过的网址，哈哈，这个样本也是恶意代码分析实战的作者写的哇。看到这些信息之后我猜的是可能会和和目标地址通信或访问它</p>
<h5 id="工具：dependencywalker"><a href="#工具：dependencywalker" class="headerlink" title="工具：dependencywalker"></a>工具：dependencywalker</h5><p><img src="https://ooo.0o0.ooo/2016/12/26/58614762dff62.png" alt="10"><br><img src="https://ooo.0o0.ooo/2016/12/26/5861477245a87.png" alt="11"><br><img src="https://ooo.0o0.ooo/2016/12/26/5861477e8f142.png" alt="12"><br>结果：我们可以看到Lab01-03.exe的dll列表包含了3个dll，MSVCRT.dll中导入的函数还是之前常见的函数，这次有两个dll没见过，OLEAUT32.DLL和OLE32.DLL,我把这两个dll中导入的函数功能列出来：<br>oleaut32.dll是对象链接与嵌入OLE相关文件<br>OLEAUT32.DLL SysAllocString：申请一个BSTR指针，并初始化为一个字符串<br>OLEAUT32.DLL SysFreeString：释放BSTR内存<br>OLEAUT32.DLL VariantInit：初始化函数<br>ole32.dll是链接和嵌入在应用程序中的对象的过程文件<br>OLE32.DLL CoCreateInstance：用指定的类标识符创建一个Com对象,用指定的类标识符创建一个未初始化的对象<br>OLE32.DLL OleInitialize：在当前单元（apartment）初始化组件对象模型（COM）库，将当前的并发模式标识为STA（single-thread apartment——单线程单元），并启用一些特别用于OLE技术的额外功能<br>OLE32.DLL OleUninitialize：释放组件对象模型</p>
<p>猜想该样本可能会在应用程序中链接和嵌入一个对象，结合查找字符串中的地址“<a href="http://www.malwareanalysisbook.com/">http://www.malwareanalysisbook.com</a> ”，我猜测该样本直接访问该地址，因为没有连接网络的函数出现</p>
<h5 id="Lab01-03-exe分析结束了，我最后得出的结论是：这个文件是用VC6-0编译出来的，加了FSG壳。它的主要功能是通过调用MSVCRT-dll，OLEAUT32-DLL和OLE32-DLL来实现。它会直接通过应用程序访问“http-www-malwareanalysisbook-com-”这个网页。"><a href="#Lab01-03-exe分析结束了，我最后得出的结论是：这个文件是用VC6-0编译出来的，加了FSG壳。它的主要功能是通过调用MSVCRT-dll，OLEAUT32-DLL和OLE32-DLL来实现。它会直接通过应用程序访问“http-www-malwareanalysisbook-com-”这个网页。" class="headerlink" title="Lab01-03.exe分析结束了，我最后得出的结论是：这个文件是用VC6.0编译出来的，加了FSG壳。它的主要功能是通过调用MSVCRT.dll，OLEAUT32.DLL和OLE32.DLL来实现。它会直接通过应用程序访问“http://www.malwareanalysisbook.com ”这个网页。"></a>Lab01-03.exe分析结束了，我最后得出的结论是：<u>这个文件是用VC6.0编译出来的，加了FSG壳。它的主要功能是通过调用MSVCRT.dll，OLEAUT32.DLL和OLE32.DLL来实现。它会直接通过应用程序访问“<a href="http://www.malwareanalysisbook.com/">http://www.malwareanalysisbook.com</a> ”这个网页。</u></h5><h5 id="运行试试："><a href="#运行试试：" class="headerlink" title="运行试试："></a>运行试试：</h5><p>前面一直都是静态分析，这次试着运行了一下，发现能看见该样本通过浏览器直接打开了目标地址的网页，验证了之前的猜想<br><img src="https://ooo.0o0.ooo/2016/12/26/58614b8922092.png" alt="13"></p>
<p>今天看到了很多脱壳的方法，一个一个的试了试，虽然还是不懂原理，但是目前分析样本（虽然都是些炒鸡简单的，but大牛们肯定很久很久以前也是从我现在这样做起的~~）和脱壳的热情很高，而且我相信慢慢学习的路途中一定会知道的越来越多哒，加油！</p>
]]></content>
      <tags>
        <tag>Unpack</tag>
        <tag>病毒分析</tag>
      </tags>
  </entry>
  <entry>
    <title>静态分析基础技术の第一个样本分析（Lab01-01）</title>
    <url>/2016/12/10/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90Lab0101/</url>
    <content><![CDATA[<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>因为想学习病毒分析，所以最近在看《恶意代码分析实战》，这个样本来源于第一章的实验（其实我也不知道我分析的对不对）。通过几个静态分析工具用静态分析基本技术，了解它的基础信息。但是因为我太菜，也没有接触过病毒样本，0基础什么都不知道，所以分析的比较浅显。</p>
<a id="more"></a>
<h4 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：Lab01-01.exe<br>时间戳：2010-12-19 16:16:19<br>MD5：bb7425b82141a1c0f7d60e5106676bb1<br>SHA1：9dce39ac1bd36d877fdb0025ee88fdaff0627cdb</p>
<h4 id="基本信息：-1"><a href="#基本信息：-1" class="headerlink" title="基本信息："></a>基本信息：</h4><p>文件名称：Lab01-01.dll<br>时间戳：2010-12-19 16:16:38<br>MD5： 290934c61de9176ad682ffdd65f0a669<br>SHA1：a4b35de71ca20fe776dc72d12fb2886736f43c22</p>
<h4 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h4><p>WinMD5，Strings，PEid，PEview，dependencywalker，resource hacker</p>
<h4 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h4><p>因为.dll文件要通过可执行文件的调用来实现相应的功能，所以我先分析Lab01-01.dll</p>
<p>首先用360查杀一下，显示没有发现威胁</p>
<p>然后我们把它上传到 <a href="https://www.virustotal.com/">https://www.virustotal.com/</a> 中检测分析<br><img src="https://ooo.0o0.ooo/2016/12/25/58600c203587b.png" alt="a"><br>结果：69%的人觉得这是恶意代码，而且我们可以从附加信息中得到它的一些基本信息。</p>
<h5 id="工具：WinMD5（也能通过windows下的工具获得MD5）"><a href="#工具：WinMD5（也能通过windows下的工具获得MD5）" class="headerlink" title="工具：WinMD5（也能通过windows下的工具获得MD5）"></a>工具：WinMD5（也能通过windows下的工具获得MD5）</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/586008057966c.png" alt="1"><br>结果：这样我们就可以知道Lab01-01.dll的MD5（由于哈希是唯一标识，所以可以在网上去搜索这段哈希找找这个恶意代码的相关信息，可能有大神已经分析过）</p>
<h5 id="工具：Strings"><a href="#工具：Strings" class="headerlink" title="工具：Strings"></a>工具：Strings</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/58600850ad4b5.png" alt="2"><br>结果：排除一些显而易见不重要的字符串，可以看到这些关键的信息。例如：Sleep，CreateProcessA,KERNEL32.dll，WS_32.dll，127.26.152.13等等。我猜测KERNEL32.dll，WS_32.dll是其中包含的重要dll，其他的是可能使用到的重要函数。通过可以看见的几个函数，猜测可能有操作进程，使系统休眠等行为，那一串IP地址可能是通过联网与该地址进行一些通信。</p>
<h5 id="工具：PEid"><a href="#工具：PEid" class="headerlink" title="工具：PEid"></a>工具：PEid</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/5860087e11723.png" alt="3"><br>结果：显示的是VC6.0. 一般这样的结果应该是没有壳的，表示是由VC6.0编译的。而且在上一部查找字符串中可以清晰的看到一串关键信息，如果有壳的话是不会看到这些信息的。所以在这里我当作没有壳，不用脱壳来处理。</p>
<h5 id="工具：PEview"><a href="#工具：PEview" class="headerlink" title="工具：PEview"></a>工具：PEview</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/586008ac6424c.png" alt="4"><br>我们再看一次.text节的信息，这里可以看到.text的虚拟大小比在磁盘上的大小要小，所以一般情况下也代表着没有加壳<br><img src="https://ooo.0o0.ooo/2016/12/25/586008ef94139.png" alt="5"><br>在.rdata节中包含的除了全局的只读数据之外，还包含导入导出的函数信息，这里看到的和我们在strings中查找的字符串中的函数和dll很相似，所以离我们的猜测更近了一步。<br><img src="https://ooo.0o0.ooo/2016/12/25/58600903107c6.png" alt="6"><br>在.data节中包含的是全局数据，这里看到了exec，sleep，hello和那串IP地址，可见这四个数据是需要重点关注的。更加肯定了之前的猜测，可能有使系统休眠的行为，那一串IP地址可能是通过联网与该地址进行一些通信，hello可能是作为字符串发往目标地址。</p>
<h5 id="工具：dependencywalker"><a href="#工具：dependencywalker" class="headerlink" title="工具：dependencywalker"></a>工具：dependencywalker</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/58600946a6f4e.png" alt="7"><br><img src="https://ooo.0o0.ooo/2016/12/25/58600983547b8.png" alt="8"><br><img src="https://ooo.0o0.ooo/2016/12/25/5860099754c8b.png" alt="9"><br><img src="https://ooo.0o0.ooo/2016/12/25/586009a70570a.png" alt="10"><br><img src="https://ooo.0o0.ooo/2016/12/25/586009b648488.png" alt="11"><br>结果：我们可以看到Lab01-01.dll的dll列表包含了三个dll，我们在KERNEL32.dll中找到了一部分导入的函数，在WS_32.dll中导入函数用的是导入序号的方式，其中有大部分运用了用于网络连接的socket这类函数，可以推测出有连接网络的迹象。在下面的所有函数列表中找到相应的函数就行，因为我是第一次完整的分析一个样本，什么都不懂，所以我把上面所导入的函数和相应的功能到列在下面，以便推测实现的功能：（虽然已经可以大致猜测出来了）</p>
<p>KERNEL32.dll CloseHandle：包括文件、文件映射、进程、线程、安全和同步对象等<br>KERNEL32.dll CreateMutex：找出当前系统是否已经存在指定进程的实例。如果没有则创建一个互斥体。<br>KERNEL32.dll  CreateProcess ：用来创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件<br>KERNEL32.dll OpenMutex：现有的一个已命名互斥体对象创建一个新句柄<br>KERNEL32.dll  sleep ：将调用它的进程挂起一段时间后继续运行，挂起时不仅不会回应用户操作，还会停止自身的运行<br>WS_32.dll closesocket：关闭套接字<br>WS_32.dll connect：建立套接字网络连接<br>WS_32.dll htons：将一个16位数由主机字节顺序转换为网络字节顺序<br>WS_32.dll inet_addr：将一个点分十进制的IP转换成一个长整数型数（u_long类型）<br>WS_32.dll recv：接收数据包<br>WS_32.dll send：发送数据包<br>WS_32.dll shutdown：关闭套接字<br>WS_32.dll socket：创建套接字<br>WS_32.dll WSAStartup：即WSA(Windows Sockets Asynchronous，Windows异步套接字)的启动命令<br>WS_32.dll WSACleanup：终止Winsock 2 DLL (Ws2_32.dll) 的使用</p>
<p>在看到send函数后，更加肯定了之前的猜测，会发送“hello”给目标地址并且接受数据包。</p>
<h5 id="工具：resource-hacker"><a href="#工具：resource-hacker" class="headerlink" title="工具：resource hacker"></a>工具：resource hacker</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/58600a4c45375.png" alt="13"><br>哦豁，是空的。</p>
<h4 id="接下来是对Lab01-01-exe的分析："><a href="#接下来是对Lab01-01-exe的分析：" class="headerlink" title="接下来是对Lab01-01.exe的分析："></a>接下来是对Lab01-01.exe的分析：</h4><p>首先用360查杀一下，显示发现高危风险项</p>
<p>然后我们把它上传到 <a href="https://www.virustotal.com/">https://www.virustotal.com/</a> 中检测分析：<br><img src="https://ooo.0o0.ooo/2016/12/25/58600c4bb945d.png" alt="b"><br>结果：只有50%的人觉得这是恶意代码，而且我们可以从附加信息中得到它的一些基本信息。</p>
<h5 id="工具：Strings-1"><a href="#工具：Strings-1" class="headerlink" title="工具：Strings"></a>工具：Strings</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/58600a8441c25.png" alt="14"><br>结果：排除一些显而易见不重要的字符串，可以看到这些关键的信息。我猜测Lab01-01.exe是通过调用KERNEL32.dll和Lab01-01.dll来实现功能的。但是这里有个KERNEL132.dll有些奇怪，和KERNEL32.dll很像，难道是用来混淆的？？太菜了，还不懂。</p>
<h5 id="工具：PEid-1"><a href="#工具：PEid-1" class="headerlink" title="工具：PEid"></a>工具：PEid</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/58600a9237fb2.png" alt="15"><br>结果：同样的显示的是VC6.0.所以在这里我当作没有壳，不用脱壳来处理。</p>
<h5 id="工具：PWview"><a href="#工具：PWview" class="headerlink" title="工具：PWview"></a>工具：PWview</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/58600aa25e29f.png" alt="16"><br>我们再看一次.text节的信息，这里可以看到.text的虚拟大小与在磁盘上的大小差不多，所以一般情况下也代表着没有加壳<br><img src="https://ooo.0o0.ooo/2016/12/25/58600ab14b0e1.png" alt="17"><br>在.rdata节中和我们在strings中查找的字符串中的函数和dll很相似，所以离我们的猜测更近了一步。<br><img src="https://ooo.0o0.ooo/2016/12/25/58600abedc207.png" alt="18"><br>在.data节中又看到了这个奇怪的KERNEL132.dll，它作为全局变量很值得关注，但是用来做什么呢，我也有些迷惑。</p>
<h5 id="工具：dependencywalker-1"><a href="#工具：dependencywalker-1" class="headerlink" title="工具：dependencywalker"></a>工具：dependencywalker</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/58600b0f791b2.png" alt="19"><br><img src="https://ooo.0o0.ooo/2016/12/25/58600b1bed68f.png" alt="20"></p>
<p>结果：我们可以看一部分导入的函数，我也把上面所导入的函数和相应的功能到列在下面，以便推测实现的功能：<br>KERNEL32.dll CopyFile：拷贝文件<br>KERNEL32.dll CreateFile：这是一个多功能的函数，可打开或创建以下对象，并返回可访问的句柄：控制台，通信资源，目录（只读打开），磁盘驱动器，文件，邮槽，管道。<br>KERNEL32.dll CreateFileMapping：创建一个新的文件映射内核对象<br>KERNEL32.dll FindClose: 关闭由FindFirstFile函数创建的一个搜索句柄<br>KERNEL32.dll FindFirstFile：根据文件名查找文件<br>KERNEL32.dll FindNextFile：用来遍历目录或文件时，判断当前目录下是否有下一个目录或文件<br>KERNEL32.dll IsBadReadPtr：该函数检查调用进程是否有读取指定内存的内容的权限<br>KERNEL32.dll MapViewOfView：为文件的数据保留一个地址空间区域，并将文件的数据作为映射到这个区域的物理存储器进行提交<br>KERNEL32.dll UnmapViewOfFile：不再需要把文件的数据映射到进程的地址空间中时，可以该函数来释放内存区域。<br>MSVCRT.dll XcptFilter：标识要执行的异常和相关事件<br>MSVCRT.dll getmainargs：调用分析的命令行并复制参数传递给 main() 返回传递的指针<br>MSVCRT.dll _p___initenv：初始化环境变量<br>MSVCRT.dll _p__commode：定默认文件提交模式。函数仅供内部使用，用户代码不应调用它<br>MSVCRT.dll _p__fmode：_p__fmode 函数仅供内部使用，用户代码不应调用它。<br>MSVCRT.dll _set_app_type：找不到具体函数功能，猜测是设置应用程序类型。<br>MSVCRT.dll _setusermatherr：指定用户提供的事务来处理算术错误，而不是_matherr事务。<br>MSVCRT.dll adjust_fdiv：找不到具体函数功能，猜测为链接时自动调用的特定模式的文件。_open_pipe 和 I/O 操作指定 binary 或 text 转换<br>MSVCRT.dll controlfp：获取和设置浮点控制字<br>MSVCRT.dll except_handler3：异常处理函数<br>MSVCRT.dll _exit/exit：终止函数。它们之间的区别是_exit函数直接将程序关闭，缓冲区中的数据就会丢失，反之，如果向保证数据的完整性，就一定要使用exit函数。<br>MSVCRT.dll initterm：内部方法指浏览函数指针表并初始化它们<br>MSVCRT.dll stricmp：比较字符串s1和s2，但不区分字母的大小写<br>MSVCRT.dll malloc：向系统申请分配指定size个字节的内存空间</p>
<p>看到FindNextFile函数，我猜测前面那个奇怪的KERNEL132.dll是作为指定的文件名，在系统目录中要遍历查找这个文件。</p>
<h5 id="工具：resource-hacker-1"><a href="#工具：resource-hacker-1" class="headerlink" title="工具：resource hacker"></a>工具：resource hacker</h5><p><img src="https://ooo.0o0.ooo/2016/12/25/58600b2ac5999.png" alt="21"><br>哦豁，还是空的。</p>
<h5 id="Lab01-01-exe和Lab01-01-dll分析结束了，我最后得出的结论是：这个文件是用VC6-0编译出来的，没有加壳。它的主要功能是通过调用KERNEL32-dll和Lab01-01-dll来实现。一方面在目录中遍历寻找Kerne132-dll文件，如果不存在就创建新Kerne132-dll文件；一方面是连接网络，发送字符串“hello”给IP为127-26-52-13的目标地址通信，并接受来自目标地址的数据包，并且能使系统休眠。"><a href="#Lab01-01-exe和Lab01-01-dll分析结束了，我最后得出的结论是：这个文件是用VC6-0编译出来的，没有加壳。它的主要功能是通过调用KERNEL32-dll和Lab01-01-dll来实现。一方面在目录中遍历寻找Kerne132-dll文件，如果不存在就创建新Kerne132-dll文件；一方面是连接网络，发送字符串“hello”给IP为127-26-52-13的目标地址通信，并接受来自目标地址的数据包，并且能使系统休眠。" class="headerlink" title="Lab01-01.exe和Lab01-01.dll分析结束了，我最后得出的结论是：这个文件是用VC6.0编译出来的，没有加壳。它的主要功能是通过调用KERNEL32.dll和Lab01-01.dll来实现。一方面在目录中遍历寻找Kerne132.dll文件，如果不存在就创建新Kerne132.dll文件；一方面是连接网络，发送字符串“hello”给IP为127.26.52.13的目标地址通信，并接受来自目标地址的数据包，并且能使系统休眠。"></a>Lab01-01.exe和Lab01-01.dll分析结束了，我最后得出的结论是：<u>这个文件是用VC6.0编译出来的，没有加壳。它的主要功能是通过调用KERNEL32.dll和Lab01-01.dll来实现。一方面在目录中遍历寻找Kerne132.dll文件，如果不存在就创建新Kerne132.dll文件；一方面是连接网络，发送字符串“hello”给IP为127.26.52.13的目标地址通信，并接受来自目标地址的数据包，并且能使系统休眠。</u></h5><p>第一次自己分析出来一个样本，虽然很简单，但是敲级开心~~啦啦啦</p>
]]></content>
      <tags>
        <tag>病毒分析</tag>
      </tags>
  </entry>
</search>
